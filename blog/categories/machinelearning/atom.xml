<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MachineLearning | Jacky and MSC]]></title>
  <link href="http://jackycode.github.io/blog/categories/machinelearning/atom.xml" rel="self"/>
  <link href="http://jackycode.github.io/"/>
  <updated>2014-04-19T14:39:11+08:00</updated>
  <id>http://jackycode.github.io/</id>
  <author>
    <name><![CDATA[Jacky Code]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习9: 聚类算法之KMeans]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/19/kmeans/"/>
    <updated>2014-04-19T13:01:02+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/19/kmeans</id>
    <content type="html"><![CDATA[<p><img src="/images/artical/artical24.jpg" alt="artical 24" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h2 id="the-k-means-algorithm">The k-means algorithm</h2>
<hr />

<p>前面写了很多监督学习的东西，除了回归就是分类，今儿有点想换换口味，写写无监督学习的算法。k-means算法是一种聚类算法，聚类就是无监督学习里面的内容。那么先来说说聚类：</p>

<h3 id="section">一、聚类简介</h3>
<hr />

<ol>
  <li>
    <p>聚类是一种无监督学习方法，它主要就是将相似的对象归并到一个类别中。</p>
  </li>
  <li>
    <p>聚类分析的目的是把分类对象按照一定的规则，分成若干个类。这些类并不是事先给定的，而是在处理数据时，根据数据的特征确定的。因而，在处理之前无需对类的数目、结构等等作出假定(理论如此，实际应用时并不完全这样，以后讲聚类分析时再具体说)。</p>
  </li>
  <li>
    <p>在同一类别中，对象具有某种意义下的相似性；不同的类别中，对象具有某种意义下的不相似。</p>
  </li>
  <li>
    <p><strong>聚类与分类的最大不同</strong>：分类的目标事先已知，而聚类未知。正因为聚类产生的结构与分类相同，只是类别没有预先定义，所以聚类也被称为“无监督分类”。</p>
  </li>
</ol>

<h3 id="k-means">二、k-means法</h3>
<hr />

<p>k-means法是由MacQueen提出并命名的一种聚类算法。其使用聚类中的均值进行聚类划分，这样说不大好理解，可以先看一下算法的基本步骤：</p>

<ol>
  <li>从n个数据对象中任意取出k个样品对象作为初始聚类点（或者将所有数据分成k份，计算每一份中的重心（均值）作为初始聚类点）；</li>
  <li>对所有样品对象逐个归类，将每一个对象归入距离他最近的那个类（距离一般使用欧式距离），并将该类的凝聚点更新为这个类当前的均值；</li>
  <li>重复步骤2，直至所有对象都不能再分配为止。</li>
</ol>

<h3 id="r">三、R语言实现</h3>
<hr />

<h4 id="section-1">1. 自定义函数</h4>
<hr />

<p>自定义一个函数<code>se_kmeans</code>，使用这个函数可以通过输入需要聚类的数据集以及类别数目k，即可得到每一个样品的类别以及各个类别的中心。该函数使用欧式距离作为相似性的度量（当然还有很多其它方式，之后的聚类分析中会讲到），具体的程序可以在<a href="/datascience">我的项目</a>中找到，也可以直接到我的<a href="https://github.com/JackyCode/Data_Science">github</a>中查看源代码。这边给出测试代码以及结果：</p>

<p>``` r
x1 &lt;- matrix(rnorm(500, 1, 0.5), 100, 5)
x2 &lt;- matrix(rnorm(500, 2, 0.5), 100, 5)
x &lt;- rbind(x1, x2)</p>

<p>clusters &lt;- se_kmeans(x, 2)
clusters
plot(x, col=clusters$cluster, pch=as.character(clusters$cluster), cex=0.5)
points(clusters$center, col=’green’, pch=’o’, cex = 2)
```</p>

<p>得到如下的一张图</p>

<p><img src="\images\a24\kmeans1.jpg" alt="kmeans1" /></p>

<p>可以看到，分类效果是很好的。</p>

<h4 id="kmeans">2. 使用<code>kmeans</code>函数</h4>
<hr />

<p>可以使用<code>stats</code>包中的<code>kmeans</code>函数来实现，示例如下：</p>

<p>``` r
x1 &lt;- matrix(rnorm(500, 1, 0.5), 100, 5)
x2 &lt;- matrix(rnorm(500, 2, 0.5), 100, 5)
x &lt;- rbind(x1, x2)</p>

<p>clusters &lt;- kmeans(x, 2)
clusters
plot(x, col=clusters$cluster, pch=as.character(clusters$cluster), cex=0.5)
points(clusters$centers, col=’green’, pch=’o’, cex = 2)
```</p>

<p>得到这样一张图</p>

<p><img src="\images\a24\kmeans2.jpg" alt="kmeans2" /></p>

<p>从图中可以看出，kmeans的分类效果还是蛮不错的，当然我们可以计算一下误判，不过这显然是很小的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习8: 决策树之ID3]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/14/id3/"/>
    <updated>2014-04-14T16:02:45+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/14/id3</id>
    <content type="html"><![CDATA[<p><img src="/images/artical/artical23.jpg" alt="artical 23" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>ID3算法的核心问题就在于：如何选取在决策树的每个节点处要测试的属性。那么如何去选择呢？当然，我们要选取<strong>分类能力最好的属性</strong>，那么怎么去确定哪个属性是分类能力最好的呢？ID3算法中，使用<strong>信息增益</strong>作为评判标准。在看信息增益之前，我们先看看这个决策树的构造过程：</p>

<h3 id="section">一、构造过程</h3>
<hr />

<ol>
  <li>选取<strong>分类能力最好的属性</strong>作为决策树根部节点的测试；</li>
  <li>为根节点属性的每一个可能值产生一个分支；</li>
  <li>以各个分支节点为根节点，重复上述过程。</li>
</ol>

<h3 id="section-1">二、信息增益</h3>
<hr />

<h4 id="section-2">1. 熵</h4>
<hr />

<p>在看信息增益之前，首先需要介绍一个概念，那就是<strong>香农熵</strong>，简称为<strong>熵</strong>。相信学过物理的应该大都听过这个名词，在热力学中不就有个熵增原理嘛。其实，<strong>熵是信息论中广泛使用的一个度量标准，刻画了任意样例集合的纯度。</strong></p>

<p><strong>熵是信息的期望值</strong>，所以可以用熵来刻画一个数据集的纯度。若用$x_i,i=1,2,\dots,n$来表示数据集所包含的属性，那么这个数据集的熵为：</p>

<script type="math/tex; mode=display"> H = - \sum_{i=1}^{n}{p(x_i)l(x_i)} </script>

<p>其中，$p(x_i)$表示选取$x_i$作为分类的最终类别的概率；$l(x_i)$为$x_i$的信息，定义为：<script type="math/tex"> l(x_i) = - \log_2p(x_i)</script>。</p>

<h4 id="section-3">2. 信息增益</h4>
<hr />

<p>有了熵之后就可以刻画一个数据集的纯度，也就是熵值。那么什么信息增益呢？</p>

<p>简单来说，<strong>一个属性的信息增益就是：使用这个属性分割样例集合而导致的熵值降低</strong>。那么要选取分类能力最好的属性，就是要选取使得信息增益最大的那个属性。</p>

<p>一个属性A对样例集合S的信息增益定义为：</p>

<script type="math/tex; mode=display"> Gain(S, A) = H(S) - \sum_{v \in A} { \frac{\# S_v}{\# S} H(S_v) } </script>

<p>其中，<script type="math/tex">S_v</script>表示集合S中，属性A取值为$v$的那部分数据；<script type="math/tex">\# S_v</script>表示，集合S中，属性A取值为$v$的个数；<script type="math/tex">\# S</script>表示集合S中观测的个数。</p>

<h4 id="section-4">3. 简单的例子</h4>
<hr />

<table>
  <thead>
    <tr>
      <th style="text-align: center">序号</th>
      <th style="text-align: center">age</th>
      <th style="text-align: center">income</th>
      <th style="text-align: center">buy_iphone</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">senior</td>
      <td style="text-align: center">high</td>
      <td style="text-align: center">yes</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">senior</td>
      <td style="text-align: center">low</td>
      <td style="text-align: center">no</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">youth</td>
      <td style="text-align: center">high</td>
      <td style="text-align: center">yes</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">youth</td>
      <td style="text-align: center">low</td>
      <td style="text-align: center">no</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">senior</td>
      <td style="text-align: center">high</td>
      <td style="text-align: center">yes</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">youth</td>
      <td style="text-align: center">high</td>
      <td style="text-align: center">yes</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">senior</td>
      <td style="text-align: center">high</td>
      <td style="text-align: center">no</td>
    </tr>
  </tbody>
</table>

<p>考虑上面这个问题，我们来计算一下各个属性的信息增益。</p>

<p>首先，我们可以看到，这个数据集S最终分类buy_iphone有两种取值：$yes,no$。则数据集S的熵值为：</p>

<script type="math/tex; mode=display"> H(S) = -\frac{4}{7} \log_2{\frac{4}{7} } - \frac{3}{7} \log_2{\frac{3}{7} }  \approx 0.985</script>

<p>若按照age分类，age有两个属性：$senior, youth$，分别有4个和3个。age = senior时，yes有2个，no有2个则有：</p>

<script type="math/tex; mode=display"> H_{age}(S_{senior}) = -\frac{2}{4} \log_2{\frac{2}{4}} - \frac{2}{4} \log_2{\frac{2}{4}} \approx 1 </script>

<script type="math/tex; mode=display"> H_{age}(S_{youth}) = -\frac{2}{3} \log_2 {\frac{2}{3}} - \frac{1}{3} \log_2 {\frac{1}{3}} \approx 0.918 </script>

<p>则有：</p>

<script type="math/tex; mode=display"> H_{age}(S) = \frac{4}{7} \times 1 + \frac{3}{7} \times 0.918 = 0.965 </script>

<p>则age属性的信息增益为：</p>

<script type="math/tex; mode=display"> H(S) - H_{age}(S) = 0.985 - 0.965 = 0.020 </script>

<p>那么属性income的信息增益怎么去计算，可以动手试试。</p>

<h3 id="id3">三、ID3算法的伪代码</h3>
<hr />

<h5 id="section-5">定义：</h5>
<ul>
  <li>data：为训练样本集</li>
  <li>label：为目标属性 （比如例子中的属性buy_iphone）</li>
  <li>attrs：出目标属性外，供算法学习测试使用的其它属性 （比如例子中的age和income属性）</li>
</ul>

<h5 id="section-6">伪代码：</h5>
<p>ID3(data, label, attrs)：</p>

<ol>
  <li>创建决策树的Root节点；</li>
  <li>若lable中取值单一，则返回 <code>label=label</code> 的单节点树；</li>
  <li>若attrs为空，则返回 <code>label=（data中取值最多的那个label）</code> 的单节点树；</li>
  <li>否则：
    <ol>
      <li>选取attrs中分类能力最好的属性作为Root的决策属性，记为A；</li>
      <li>对A的每一个可能取值vi：
        <ol>
          <li>在Root添加一个分支对应 <code>A = vi </code>；</li>
          <li>data_vi = data中 <code>A = vi</code> 的子集，label_vi 表示 data_vi 所对应的目标属性取值；</li>
          <li>若 data_vi 为空集：
            <ol>
              <li>在新分支下加一个叶子节点，节点 <code>label =（data中取值最多的那个label）</code> ;</li>
              <li>否则，加一个子树：ID3(data_vi, label_vi, attrs);</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>结束</li>
  <li>返回Root</li>
</ol>

<h3 id="r">四、R语言实现</h3>
<hr />

<p>见<a href="/datascience">我的项目</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习7: 决策树]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/11/decision-trees/"/>
    <updated>2014-04-11T19:00:32+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/11/decision-trees</id>
    <content type="html"><![CDATA[<p><img src="/images/artical/artical21.jpg" alt="artical 21" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h3 id="section">一、开始</h3>
<hr />

<p>在介绍决策树的概念内容之前，先来初步了解一下决策树的流程。这是一个很简单的概念，通过一张简单的流程图就可以大致了解决策树是干什么的，怎么干的。</p>

<p><img src="\images\a21\decisiontrees.jpg" alt="decision trees" /></p>

<h3 id="section-1">二、相关概念</h3>
<hr />

<h4 id="section-2">1. 一些概念</h4>
<hr />

<ul>
  <li>决策树学习是一种逼近离散值目标函数的方法。</li>
  <li>决策树通过把实例从根节点排列到某个叶子节点来分类实例，叶子的节点即为实例所属的分类。</li>
  <li>决策树上的每一个节点，指定了对实例的某一个属性的测试，并且，该节点的每一个后续分支对应该属性的一个可能值。</li>
</ul>

<h4 id="section-3">2. 分类方法</h4>
<hr />
<p>从树的根节点开始，测试这个节点指定的属性，然后按照给定实例的该属性值对应的分支向下移动。然后以新节点作为根节点重复上面的过程直至结束。</p>

<h3 id="section-4">三、 评价</h3>
<hr />

<p>通过决策树的流程，可以发现决策树的计算复杂度不高，而且其输出的结果易于理解，并且对缺失值不敏感。</p>

<p>但是，正是由于其划分过于细致，可能会导致过度匹配问题(与回归中的overfitting类似)。</p>

<h3 id="section-5">四、主要的决策树算法</h3>
<hr />

<p>从决策树的流程可以看出，<strong>如何选择属性作为节点以测试实例</strong>是最为关键的一步。不同的算法采取了不同的方法，主要的决策树算法有这样几个：</p>

<ul>
  <li>ID3</li>
  <li>C4.5 （数据挖掘十大算法之一，也是ID3算法的改进）</li>
  <li>C5.0 （C4.5的改进，适用于处理大数据集，采用Boosting方式提高模型准确率，因而又称BoostingTrees。）</li>
  <li>CART（数据挖掘十大算法之一）</li>
</ul>

<p>下一篇就开始讲讲一些决策树的算法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习6: 分类之朴素贝叶斯]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/08/naive-bayes/"/>
    <updated>2014-04-08T15:54:37+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/08/naive-bayes</id>
    <content type="html"><![CDATA[<p><img src="/images/artical/artical20.jpg" alt="artical 20" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h3 id="knn">0、kNN算法的优缺点</h3>
<p>与kNN算法一样，朴素贝叶斯算法也是数据挖掘十大算法之一。我们介绍kNN算法时，并没有讨论kNN算法的优缺点，这边首先看看这个问题。</p>

<p>从构造kNN算法的过程可以看到，这个分类算法的<strong>精度很高</strong>。因为这个算法计算了所有点与待分类点之间的相似度，然后去确定带分类点的类别。由此可见，这个算法对<strong>异常值并不敏感</strong>。但是正是因为它需要计算所有点之间的距离，所以其<strong>复杂度是很高的</strong>，换句话就是，如果数据量大的话，这个算法会很费时，并不高效。</p>

<h3 id="section">一、贝叶斯决策</h3>
<hr />

<p>贝叶斯定理给出了条件概率之间的关系，是一个非常重要的定理。这里直接给出贝叶斯定理的结论：</p>

<script type="math/tex; mode=display"> P(B  \mid A) = \frac{P(A \mid B)P(B) }{P(A)} </script>

<p>在贝叶斯决策理论里面，要判断点$x$是否属于$C_i$类，只要验证是否存在：</p>

<script type="math/tex; mode=display"> p(C_i \mid x) = \max_{j} \{ P(C_j \mid x) \} </script>

<p>即是，使得$p(C_i \mid x)$达到最大的那个$C_i$就是$x$所属的类别。</p>

<h3 id="section-1">二、具体流程</h3>
<hr />

<p>要计算<script type="math/tex">P(C_i \mid x)</script>，那么就需要计算<script type="math/tex">\frac{P(x \mid C_i)P(C_i )}{P(x)}</script>，我们知道对于每一个<script type="math/tex">P(C_i \mid x)</script>，其计算公式中的分母都是<script type="math/tex">P(x)</script>，所以有：</p>

<script type="math/tex; mode=display"> P(C_i \mid x) \propto P(x \mid C_i)P(C_i ) </script>

<p>所以我们实际计算时，只需要考虑上式右侧的大小即可。首先我们来确定一些符号的意思：</p>

<ul>
  <li><script type="math/tex">x = [x_1, x_2, \dots, x_p]</script>为一个带分类的项，$x_i$为其特征；</li>
  <li>data表示一个已知分类的数据集($n \times p$的矩阵)，其每一行代表一个观测，每一列代表一个特征；</li>
  <li>label表示data中每一个数据对应的类别标签($ n \times 1$的矩阵)，比如data的第一行观测的类别就是label中的第一个取值；</li>
  <li><script type="math/tex">C = [ C_1, C_2, \dots, C_m ]</script>为一个类别集合，一般来说$ m &lt; p $。</li>
</ul>

<h5 id="section-2">步骤：</h5>

<ol>
  <li>
    <p>在已知分类的数据集data中统计：</p>

<script type="math/tex; mode=display">P(C_i), i = 1, 2, \dots, m</script>

<script type="math/tex; mode=display">P(x_j \mid C_i), i = 1, 2, \dots, m; j = 1, 2, \dots p</script>
  </li>
  <li>
    <p>计算</p>

<script type="math/tex; mode=display">P(x \mid C_i)P(C_i ) = P(C_i) \prod_{j=1}^{p} {P(x_j \mid C_i)}, i = 1, 2, \dots, m</script>
  </li>
  <li>
    <p>若</p>

<script type="math/tex; mode=display">P(x \mid C_k)P(C_k) = \max\{ P(x \mid C_i)P(C_i ) \}</script>

    <p>则<script type="math/tex"> x \in C_k</script>。</p>
  </li>
</ol>

<h3 id="section-3">三、一些存在的问题</h3>
<hr />

<ol>
  <li>当步骤的第2步中，<script type="math/tex">P(x \mid C_i)P(C_i ) = P(C_i) \prod_{j=1}^{p} {P(x_j \mid C_i)}, i = 1, 2, \dots, m</script>，中<script type="math/tex">P(x_j \mid C_i)</script>可能在样本较小时取值出现0，那么就会影响乘积；</li>
  <li>计算机计算时会出现精度问题，比如，如果<script type="math/tex">P(x_j \mid C_i)</script>的值有很多都是非常小的（像0.000001），那么计算机在计算是会将其四舍五入成0。</li>
</ol>

<p>出现上面的情况应该怎么办呢？</p>

<p>学数学的应该都清楚，遇到这种问题有一个很简单的处理方式，那就是取个对数。虽说取对数后会改变值的大小，但是取对数不会改变原本数据趋势，即原来大的数，取对数后还是大的。</p>

<p>此外，对于<script type="math/tex">P(x_j \mid C_i)</script>可能在样本较小时取值出现0的情况，处理也很简单，那就是将每一个$x_j$的初值都设置成1，所有特征的基数都从1开始，不会影响结果。（这时需要注意，所有特征的初值都是1，对应的总数初值也会发生变化。）</p>

<h3 id="r">四、R语言实现</h3>
<hr />

<p>见<a href="/datascience">我的项目</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习5：分类之k-近邻算法]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/05/knn/"/>
    <updated>2014-04-05T19:59:29+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/05/knn</id>
    <content type="html"><![CDATA[<p><img src="/images/artical/artical19.jpg" alt="artical 19" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h4 id="section">基本思想</h4>
<hr />

<p>kNN，k-Nearest Neighbor algorithm，也就这边的k-近邻算法，是数据挖掘十大算法之一，是一个比较简单的分类方法。</p>

<p>其基本的思想是：对于一个输入样本（未知分类的样本），考虑其与测试样本中与之距离最近（特征最相似）的k个样本，用这k个样本中出现最多的分类作为输入样本的分类。</p>

<h4 id="section-1">具体流程</h4>
<hr />

<p>对于输入样本中的每一个点，进行以下操作：</p>

<ol>
  <li>计算点与测试样本中点的距离；</li>
  <li>取出与当前点距离最小的k个点；</li>
  <li>确定k个点的分类，计算各个分类的频数；</li>
  <li>返回频数最高的类别，作为该输入点的预测分类。</li>
</ol>

<h4 id="section-2">距离的计算</h4>
<hr />

<p>上面一直在说，计算输入样本中点与测试样本中点之间的距离，那么这个距离应该怎么计算呢？这个距离一般就是使用欧式距离：</p>

<script type="math/tex; mode=display"> d = \sqrt{(x - y)^T(x - y)} </script>

<p>其中<script type="math/tex">x^T=[x_1, x_2,\dots,x_n], y^T=[y_1,y_2,\dots,y_n]</script>。二维的表示就是：</p>

<script type="math/tex; mode=display"> d = \sqrt{(x - y)^T(x - y)} = \sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2} </script>

<h4 id="r">R语言实现</h4>
<hr />

<p>见<a href="https://github.com/JackyCode/Data_Science/tree/master/kNN">我的github</a>。</p>
]]></content>
  </entry>
  
</feed>
