---
layout: post
title: "R语言记录4：自定义函数的深入"
date: 2014-03-10 16:50:29 +0800
comments: true
categories: RSeries
---

![ariticle 7](/images/article/article7.jpg)
<!-- more -->

*“文章原创，转载请注明出处”*

***

在第一份笔记中，已经介绍过控制语句以及自定义函数。但是当时讲的很简单，只是讲了语法。这次打算深入介绍一下，如何在R中写出一个稳健的自定义函数。首先先介绍一个常用的控制语句`ifelse`。

#### 一. 善用`ifelse`

###### 1. 首先生成一组成绩数据
``` r ifelse_use https://github.com/JackyCode/RSeries
> scoreList <- list()
> scoreList$name <- c("Wang", "Li", "Sun")
> scoreList$score <- c(90, 50, 70)
```

###### 2. 然后对成绩进行分级
一般来说，可能我们会想到利用循环，在学生成绩中一个一个比较。大于$60$及格，小于就不及格。但是循环相对而言是费资源的，在R语言中，处理像这种问题，完全可以避开循环去做。回想一下，之前讲`any`和`all`函数时，可以使用`which`函数取出满足条件的元素的位置。当然这也是一个不错的方式，但其实还有更好的方法，那就是利用`ifelse`函数：

``` r ifelse_use https://github.com/JackyCode/RSeries
> con <- scoreList$score > 60
> scoreList$level <- ifelse(con, "good", "not good")
```

如果使用`which`函数的话，也不复杂：

``` r ifelse_use https://github.com/JackyCode/RSeries
> scoreList$level2 <- rep("good", 3)
> scoreList$level2[which(scoreList$score<60)] <- "not good"
```

上面两种方式比较起来的话，当然个人更喜欢第一种啦。便于理解逻辑性也强。不过第二种方式怎么看怎么觉得牛，哈哈。

#### 二. 自定义函数的深入

###### 1. 首先先设计一个计算简单的函数
R语言是统计软件，那么就设计一个函数，能够输出一组值的均值，方差好了。

``` r custome_function https://github.com/JackyCode/RSeries
Summary.MeanAndSd <- function (x) {
  mean <- mean(x)
  sd <- sd(x)
}
```
这样看起来程序已经写好了，但其实是有问题的。我们来测试一下。

###### 2. 生成一组服从$N(0,1)$的随机数用来测试

``` r custom_function https://github.com/JackyCode/RSeries
> set.seed(10)	# 设定种子
> x <- rnorm(20, 0, 1)

Summary.MeanAndSd(x)
result <- Summary.MeanAndSd(x)
```
运行可以发现，直接调用函数`Summary.MeanAndSd`函数没有任何输出；即使赋值给`result`，`result`也只得到了方差。

###### 3. 选择返回值(`return`函数):

``` r custom_function https://github.com/JackyCode/RSeries
Summary.MeanAndSd <- function (x) {
  mean <- mean(x)
  sd <- sd(x)

  return(c(mean, sd))
}

> Summary.MeanAndSd(x)
[1] -0.06053267  0.79990931
```

这次就可以得到输出，赋值给`result`也就可以成功了。下面我们来将程序加一个功能，那就是计算置信区间。

###### 4. 函数参数：
计算置信区间，那就需要知道置信度$\alpha$的大小。这个时候函数就必须能够接受参数：

``` r custom_function https://github.com/JackyCode/RSeries
Summary.MeanAndSd <- function (x, alpha) {
  mean <- mean(x)
  sd <- sd(x)
  upper <- 1 - alpha/2
  ci <- mean + c(-1, 1) * qnorm(alpha/2, 0, 1)*sd/sqrt(length(x)) # qnorm计算正态分布的分位数

  return(list(mean = mean, sd = sd, ci = ci)) # 使用列表输出结果是常用方式
}

Summary.MeanAndSd(x, 0.05)
```
运行上面的程序能够很轻松地得到结果。但是，如果我们运行`Summary.MeanAndSd(x)`，程序就会报错，它会提醒你没有键入`alpha`。但实际上，大部分默认情况下，$\alpha=0.05$，完全可以将其设定成默认值：

``` r custom_function https://github.com/JackyCode/RSeries
Summary.MeanAndSd <- function (x, alpha=0.05) {
  mean <- mean(x)
  sd <- sd(x)
  upper <- 1 - alpha/2
  ci <- mean + c(-1, 1) * qnorm(alpha/2, 0, 1)*sd/sqrt(length(x)) # qnorm计算正态分布的分位数

  return(list(mean = mean, sd = sd, ci = ci)) # 使用列表输出结果是常用方式
}
```

这回再运行`Summary.MeanAndSd(x)`可以发现没有问题了。这里我们选取了列表作为输出的方式，这是一个常用的方式，利于查看保存。

###### 5. 参数的合法性：
我们知道$\alpha$是介于$(0,1)$之间的值，而且一般来说，$\alpha<0.5$。但上面的程序并不能够处理这类的问题，当参数不合法时，它依然能够计算出一个结果：

``` r custom_function https://github.com/JackyCode/RSeries
> Summary.MeanAndSd(x, 1.5)
$mean
[1] -0.06053267

$sd
[1] 0.7999093

$ci
[1] -0.18117539  0.06011005

> Summary.MeanAndSd(x, 0.8)
$mean
[1] -0.06053267

$sd
[1] 0.7999093

$ci
[1] -0.0152177 -0.1058476
```

这样的结果显然是不合理的，函数并不具备一定的报错能力。对于用户不合法的输入参数，程序要能够及时停止程序的运行，并且告诉用户哪里错了。

``` r custom_function https://github.com/JackyCode/RSeries
Summary.MeanAndSd <- function (x, alpha=0.05) {
  if (alpha <= 0 || alpha >= 1) {
    stop("The argument 'alpha' should be between 0 and 1!" )
  } else if (alpha > 0.5) {
    warning("The argument 'alpha' is often smaller than 0.5 and  close to 0!")
  }

  mean <- mean(x)
  sd <- sd(x)
  upper <- 1 - alpha/2
  ci <- mean + c(-1, 1) * qnorm(alpha/2, 0, 1)*sd/sqrt(length(x)) # qnorm计算正态分布的分位数

  return(list(mean = mean, sd = sd, ci = ci)) # 使用列表输出结果是常用方式
}
```

运行一下：

``` r custom_function https://github.com/JackyCode/RSeries
> Summary.MeanAndSd(x, 1.5)
Error in Summary.MeanAndSd(x, 1.5) :
  The argument 'alpha' should be between 0 and 1!
> Summary.MeanAndSd(x, 0.8)
$mean
[1] -0.06053267

$sd
[1] 0.7999093

$ci
[1] -0.0152177 -0.1058476

Warning message:
In Summary.MeanAndSd(x, 0.8) :
  The argument 'alpha' is often smaller than 0.5 and  close to 0!
```

这样程序就具备了一定的稳健性，能够具备一些报错的能力。但是在实际处理数据的时候，往往还会遇到一种情况，那就是缺失值。想想看，上面写的程序能够很好地应付存在缺失值的数据吗？显然是不行的。

###### 6. 注意缺失值

``` r custom_function https://github.com/JackyCode/RSeries
# 生成一组具有缺失值的数据
> set.seed(10)
> y <- rnorm(20, 0, 1)
> y <- c(y, NA)
```

试试上面的程序，能否得到结果:

``` r custom_function https://github.com/JackyCode/RSeries
> Summary.MeanAndSd(y)
$mean
[1] NA

$sd
[1] NA

$ci
[1] NA NA
```

显然上面的程序无法处理存在缺失值的数据。回想一下，我们之前学过`na.rm`参数，我们可以通过设定此参数剔除缺失值：

``` r custom_function https://github.com/JackyCode/RSeries
Summary.MeanAndSd <- function (x, alpha=0.05) {
  if (alpha <= 0 || alpha >= 1) {
    stop("The argument 'alpha' should be between 0 and 1!" )
  } else if (alpha > 0.5) {
    warning("The argument 'alpha' is often smaller than 0.5 and  close to 0!")
  }
  if (any(is.na(y))) {
    warning("There are any 'NA' in the data, we'll ignore these datas!")
  }

  mean <- mean(x, na.rm=TRUE)
  sd <- sd(x, na.rm=TRUE)
  n <- ifelse(any(is.na(y)), length(x)-sum(is.na(x)), length(x)) # n <- length(x)-sum(is.na(x)) 也可以
  upper <- 1 - alpha/2
  ci <- mean + c(-1, 1) * qnorm(alpha/2, 0, 1)*sd/sqrt(n) # qnorm计算正态分布的分位数

  return(list(mean = mean, sd = sd, ci = ci)) # 使用列表输出结果是常用方式
}
```

现在运行一下：

``` r custom_function https://github.com/JackyCode/RSeries
> Summary.MeanAndSd(y)
$mean
[1] -0.06053267

$sd
[1] 0.7999093

$ci
[1]  0.2900366 -0.4111019

Warning message:
In Summary.MeanAndSd(y) :
  There are any 'NA' in the data, we'll ignore these datas!
```

这样上面的程序就具备了处理缺失值的能力，它能够自动识别数据中是否存在缺失值，如果存在的话就剔除缺失值再进行计算，并且提醒用户存在缺失值。

但其实R语言中存在另外一个方式，可以使得程序具备处理缺失值等等的问题。可以使用使用`...`参数，使得自定义函数能够接受其它某些函数的参数，想象一下，如果可以这样调用我们的函数，`Summary.MeanAndSd(y, na.rm=TRUE)`，是不是perfect。

``` r custom_function https://github.com/JackyCode/RSeries
Summary.MeanAndSd <- function (x, alpha=0.05, ...) {
  if (alpha <= 0 || alpha >= 1) {
    stop("The argument 'alpha' should be between 0 and 1!" )
  } else if (alpha > 0.5) {
    warning("The argument 'alpha' is often smaller than 0.5 and  close to 0!")
  }
  # ellipsis.arguments <- list(...)

  mean <- mean(x, ...)
  sd <- sd(x, ...)
  n <- ifelse(any(is.na(y)), length(x)-sum(is.na(x)), length(x))
  upper <- 1 - alpha/2
  ci <- mean + c(-1, 1) * qnorm(alpha/2, 0, 1)*sd/sqrt(n) # qnorm计算正态分布的分位数

  return(list(mean = mean, sd = sd, ci = ci)) # 使用列表输出结果是常用方式
}
```

这样就可以直接使用`Summary.MeanAndSd(y, na.rm=TRUE)`来计算了。

###### 7. 递归函数
递归函数即自调用函数，有些时候我们会使用到，这里举个例子：

``` r Recall_use https://github.com/JackyCode/RSeries
plusFun1 <- function (x) {
  return(ifelse(x < 10, plusFun(x + 1), x))
}
```

当然也可以使用R的内置函数`Recall`：

``` r Recall_use https://github.com/JackyCode/RSeries
plusFun2 <- function (x) {
  return(ifelse(x < 10, Recall(x+1), x))
}
```

#### 三. 小结
今天讲了如何在R语言里面构造一个稳健的函数，以及`ifelse`和`Recall`函数的使用。写完这些，基本上R语言的基础就结束了。下面就开始写如何使用R语言去解决统计问题。由于我是概率统计专业的，而且是数学系出生，所以写的东西会有不少的理论。