---
layout: post
title: "R语言记录8：Loop Functions"
date: 2014-05-04 14:56:40 +0800
comments: true
categories: RSeries
---

![aritical 30](/images/artical/artical30.jpg)
<!-- more -->

*“文章原创，转载请注明出处”*

***

循环对于编程的重要性不言而喻，但是大量的使用`for`语句、`while`语句在R语言这种交互式命令行上，其实并不和谐。而且，很多时候，我们希望使用更短更少的代码去完成一个事情。这就需要用到R语言中自带的一些函数，使用这些函数可以把循环变得容易表述。不过，这当然是有学习成本的，要想掌握得多尝试多思考。

在RSeries系列中，我之前也介绍过`tapply`这样的Loop function，但是并没有很全面地去说这个问题。没有介绍这块内容呢，总觉得对于R语言编程来说缺少了点什么，今天就来详细地说说R语言中的Loop Functions。

在R语言中，处理循环的函数常用的大致有这么几个：`lapply`, `sapply`, `apply`, `tapply`, `mapply`。每一个函数都有其自身的特性与用途，下面我们来一个一个地说。

***

#### 1. `lapply`函数
***

`lapply`函数：**对list的每一个元素(list[[i]])执行指定的函数操作，其返回值总是一个列表**。举个简单地例子，比如：


```r
x <- list(1:4, 2:5, 10:14)
lapply(x, mean)
```

```
## [[1]]
## [1] 2.5
## 
## [[2]]
## [1] 3.5
## 
## [[3]]
## [1] 12
```


也就是对列表x的每一个元素`x[[i]]`执行指定的函数操作，这边就是求均值`mean`。

当然，`lapply`函数不仅仅可以对列表做出处理，也可以是向量，不过这个情况并不适用于任何地方。比如，你想生成随机数，第一次生成1个，第二次生成3个，第三次5个，那么可以试试这个函数：


```r
lapply(c(1, 3, 5), rnorm)
```

```
## [[1]]
## [1] -0.5622
## 
## [[2]]
## [1] -0.8519  0.3671  0.4243
## 
## [[3]]
## [1]  0.09395 -1.19474  1.52337 -1.97529  0.47370
```


这样使用的情况非常少，使用时需要特别注意一下。

当然，在`lapply`中你也可以使用自定义的函数，比如：


```r
x <- list(1:4, 2:5, 10:14)
lapply(x, function(item) any(item == 5))
```

```
## [[1]]
## [1] FALSE
## 
## [[2]]
## [1] TRUE
## 
## [[3]]
## [1] FALSE
```


这边，自定义函数中使用`item`代表`x`的每一个元素，你也可以使用任何你想用的字符表示。

***

#### 2. `sapply`函数
***

`sapply`函数与`lapply`函数使用与处理上完全相同，唯一不同的是，`sapply`会尽可能地简化输出地结果。如果可能，`sapply`会输出向量或者矩阵；当然，如果实在不行，它就会输出列表，这个时候就与`lapply`函数一模一样了。接着上面一个例子看看：


```r
x <- list(1:4, 2:5, 10:14)
sapply(x, function(item) any(item == 5))
```

```
## [1] FALSE  TRUE FALSE
```


***

#### 3. `apply`函数
***

`apply`函数：对数组或矩阵，按行或者按列进行指定的函数操作。看个简单地例子：


```r
x <- matrix(1:12, 4, 3)
x
```

```
##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
```

```r

apply(x, 1, mean)
```

```
## [1] 5 6 7 8
```

```r
apply(x, 2, mean)
```

```
## [1]  2.5  6.5 10.5
```


其中，`apply(data, margin, fun)`，`margin=1`即是按行求；`margin=2`即是按列求。

***

#### 4. `tapply`函数
***

`tapply`函数：对向量的一个子集执行指定的函数。


```r
str(tapply)
```

```
## function (X, INDEX, FUN = NULL, ..., simplify = TRUE)
```


其中`x`是需要处理的向量，`INDEX`是因子(因子列表)，`FUN`是需要执行的函数，`simplify`指是否简化输入结果(考虑sapply对于lapply的简化)。

看个简单地例子：


```r
x <- 1:12
x
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12
```

```r

Index <- gl(3, 4)
Index
```

```
##  [1] 1 1 1 1 2 2 2 2 3 3 3 3
## Levels: 1 2 3
```

```r

Index2 <- gl(4, 3)
Index2
```

```
##  [1] 1 1 1 2 2 2 3 3 3 4 4 4
## Levels: 1 2 3 4
```

```r

tapply(x, Index, sum)
```

```
##  1  2  3 
## 10 26 42
```

```r
tapply(x, Index2, sum)
```

```
##  1  2  3  4 
##  6 15 24 33
```


不简化输出结果：


```r
tapply(x, Index2, sum, simplify = FALSE)
```

```
## $`1`
## [1] 6
## 
## $`2`
## [1] 15
## 
## $`3`
## [1] 24
## 
## $`4`
## [1] 33
```


#### 5. `mapply`函数
***

`mapply`函数：对一个函数，使用指定的参数集合进行运算。看个简单地例子：


```r
mapply(mean, 1:4, 5:8, 3:6)
```

```
## [1] 1 2 3 4
```


上面这个指令进行了什么运算呢？就是计算了集合(1,5,3),(2,6,4),(3,7,5),(4,8,6)四个集合各自的平均值。

##### 如何处理其他参数

很多时候，函数并非只有一个输入参数，有一些其它的参数怎么处理呢？

使用`rnorm`函数来举个例子：


```r
set.seed(10)
mapply(rnorm, 1:3, mean = 2, sd = 1:3)
```

```
## [[1]]
## [1] 2.019
## 
## [[2]]
## [1]  1.6315 -0.7427
## 
## [[3]]
## [1] 0.2025 2.8836 3.1694
```

```r
set.seed(10)
mapply(rnorm, 1:3, mean = 1:3, sd = 1)
```

```
## [[1]]
## [1] 1.019
## 
## [[2]]
## [1] 1.8157 0.6287
## 
## [[3]]
## [1] 2.401 3.295 3.390
```


上述的命令应该与下面的命令效果相同：


```r
set.seed(10)
list(rnorm(1, 2, 1), rnorm(2, 2, 2), rnorm(3, 2, 3))
```

```
## [[1]]
## [1] 2.019
## 
## [[2]]
## [1]  1.6315 -0.7427
## 
## [[3]]
## [1] 0.2025 2.8836 3.1694
```

```r
set.seed(10)
list(rnorm(1, 1, 1), rnorm(2, 2, 1), rnorm(3, 3, 1))
```

```
## [[1]]
## [1] 1.019
## 
## [[2]]
## [1] 1.8157 0.6287
## 
## [[3]]
## [1] 2.401 3.295 3.390
```

#### 小节
***

Loop Functions可以在很大程度上简化我们所写的代码，能够帮我们简化很多操作，比如重复地输入一些东西等等！学好它可能对于程序运行本身没有多大的帮助，但是代码并不只是写给计算机看的，也是写给人看的！我认为，好的代码应该是简洁舒适的，阅读起来让自己和别人都觉得是一种美的享受！