<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Jacky and MSC]]></title>
  <link href="http://jackycode.github.io/atom.xml" rel="self"/>
  <link href="http://jackycode.github.io/"/>
  <updated>2014-06-04T17:06:03+08:00</updated>
  <id>http://jackycode.github.io/</id>
  <author>
    <name><![CDATA[Jacky Code]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[R语言绘图3：基础图形2]]></title>
    <link href="http://jackycode.github.io/blog/2014/06/04/basic-graph2/"/>
    <updated>2014-06-04T16:53:08+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/06/04/basic-graph2</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical38.jpg" alt="artical 38" />
<!-- more --></p>

<p>图片为本文中的某一张~~</p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h3 id="section">三、直方图</h3>
<hr />

<p>前面介绍的两种图形，一般都是用来处理离散数据的。那么对于连续数据，常用的图形就有这里所说的直方图。直方图在横轴上将数据值域划分成若干个组别，然后在纵轴上显示其频数。通过这种方式，可以将连续的点离散化，从而来描述连续型变量的分布。</p>

<p>在R语言中，可以使用<code>hist()</code>函数来绘制直方图：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## 构造数据</span>
</span><span class="line">set.seed<span class="p">(</span><span class="m">1234</span><span class="p">)</span>
</span><span class="line">x <span class="o">&lt;-</span> rnorm<span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
</span><span class="line"><span class="c1">## 设置画布</span>
</span><span class="line">par<span class="p">(</span>mfrow <span class="o">=</span> c<span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">))</span>
</span><span class="line"><span class="c1">## 1</span>
</span><span class="line">hist<span class="p">(</span>x<span class="p">)</span>
</span><span class="line">box<span class="p">()</span>
</span><span class="line"><span class="c1">## 2 修改颜色，组数</span>
</span><span class="line">hist<span class="p">(</span>x<span class="p">,</span> breaks <span class="o">=</span> <span class="m">10</span><span class="p">,</span> col <span class="o">=</span> <span class="s">&quot;gray&quot;</span><span class="p">)</span>
</span><span class="line">box<span class="p">()</span>
</span><span class="line"><span class="c1">## 3 添加核密度曲线</span>
</span><span class="line">hist<span class="p">(</span>x<span class="p">,</span> breaks <span class="o">=</span> <span class="m">10</span><span class="p">,</span> freq <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span> col <span class="o">=</span> <span class="s">&quot;gray&quot;</span><span class="p">)</span>
</span><span class="line">lines<span class="p">(</span>density<span class="p">(</span>x<span class="p">),</span> col <span class="o">=</span> <span class="s">&quot;red&quot;</span><span class="p">,</span> lwd <span class="o">=</span> <span class="m">2</span><span class="p">)</span>
</span><span class="line">box<span class="p">()</span>
</span><span class="line"><span class="c1">## 4 添加正态密度曲线</span>
</span><span class="line">h <span class="o">&lt;-</span> hist<span class="p">(</span>x<span class="p">,</span> breaks <span class="o">=</span> <span class="m">10</span><span class="p">,</span> col <span class="o">=</span> <span class="s">&quot;gray&quot;</span><span class="p">)</span>
</span><span class="line">xfit <span class="o">&lt;-</span> seq<span class="p">(</span>min<span class="p">(</span>x<span class="p">),</span> max<span class="p">(</span>x<span class="p">),</span> length <span class="o">=</span> <span class="m">100</span><span class="p">)</span>
</span><span class="line">yfit <span class="o">&lt;-</span> dnorm<span class="p">(</span>xfit<span class="p">,</span> mean <span class="o">=</span> mean<span class="p">(</span>x<span class="p">),</span> sd <span class="o">=</span> sd<span class="p">(</span>x<span class="p">))</span>
</span><span class="line">yfit <span class="o">&lt;-</span> yfit <span class="o">*</span> diff<span class="p">(</span>h<span class="o">$</span>mids<span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="p">])</span> <span class="o">*</span> length<span class="p">(</span>x<span class="p">)</span>
</span><span class="line">lines<span class="p">(</span>xfit<span class="p">,</span> yfit<span class="p">,</span> col <span class="o">=</span> <span class="s">&quot;blue&quot;</span><span class="p">,</span> lwd <span class="o">=</span> <span class="m">2</span><span class="p">)</span>
</span><span class="line">box<span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a38/hist.png" alt="plot of chunk hist" /></p>

<p>当然，可以使用<code>ggplot2</code>包中的函数绘制直方图：</p>

<p>先试试<code>qplot()</code>函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">qplot<span class="p">(</span>x<span class="p">,</span> geom <span class="o">=</span> <span class="s">&quot;histogram&quot;</span><span class="p">,</span> binwidth <span class="o">=</span> <span class="m">0.5</span><span class="p">,</span> fill <span class="o">=</span> ..count..<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a38/hist_qplot.png" alt="plot of chunk hist_qplot" /></p>

<p>再试试<code>ggplot()</code>函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">dataSet <span class="o">&lt;-</span> data.frame<span class="p">(</span>x<span class="p">)</span>
</span><span class="line">h <span class="o">&lt;-</span> ggplot<span class="p">(</span>data <span class="o">=</span> dataSet<span class="p">,</span> aes<span class="p">(</span>x <span class="o">=</span> x<span class="p">))</span>
</span><span class="line">h <span class="o">+</span> geom_histogram<span class="p">(</span>aes<span class="p">(</span>fill <span class="o">=</span> ..count..<span class="p">),</span> binwidth <span class="o">=</span> <span class="m">0.5</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a38/hist_ggplot1.png" alt="plot of chunk hist_ggplot" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## 添加核密度曲线</span>
</span><span class="line">h <span class="o">+</span> geom_histogram<span class="p">(</span>aes<span class="p">(</span>y <span class="o">=</span> ..density..<span class="p">,</span> fill <span class="o">=</span> ..count..<span class="p">),</span> binwidth <span class="o">=</span> <span class="m">0.5</span><span class="p">)</span> <span class="o">+</span>
</span><span class="line">    geom_density<span class="p">(</span>color <span class="o">=</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a38/hist_ggplot2.png" alt="plot of chunk hist_ggplot" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## 添加正态密度曲线</span>
</span><span class="line">dataSet2 <span class="o">&lt;-</span> data.frame<span class="p">(</span>xfit<span class="p">,</span> yfit<span class="p">)</span>
</span><span class="line">h <span class="o">+</span> geom_histogram<span class="p">(</span>aes<span class="p">(</span>fill <span class="o">=</span> ..count..<span class="p">),</span> binwidth <span class="o">=</span> <span class="m">0.5</span><span class="p">)</span> <span class="o">+</span> geom_line<span class="p">(</span>data <span class="o">=</span> dataSet2<span class="p">,</span>
</span><span class="line">    aes<span class="p">(</span>x <span class="o">=</span> xfit<span class="p">,</span> y <span class="o">=</span> yfit<span class="p">),</span> color <span class="o">=</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a38/hist_ggplot3.png" alt="plot of chunk hist_ggplot" /></p>

<p>直方图在统计中是非常重要的，我自己的感觉是：散点图用的最多最广泛，其次就是直方图！散点图之前已经说过，直方图的话，它可以直观地显示出样本数据大致的分布情况（经验分布函数），对选择什么样的分布、什么样的模型等等都有一定的作用。使用核函数以及正态密度曲线与之结合，能够更好地观察出样本数据的一些分布特征，所以，学会绘制直方图是十分重要的。</p>

<h3 id="section-1">四、箱线图</h3>
<hr />

<p>还有一种常用的图形，就是<strong>箱线图</strong>，也称<strong>盒须图</strong>。它通过绘制连续型变量的五个分位数（最大最小值、25%和75%分位数以及中位数），描述变量的分布。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## 构造数据</span>
</span><span class="line">x1 <span class="o">&lt;-</span> x
</span><span class="line">x2 <span class="o">&lt;-</span> rnorm<span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
</span><span class="line">x3 <span class="o">&lt;-</span> rnorm<span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
</span><span class="line">all_x <span class="o">&lt;-</span> c<span class="p">(</span>x1<span class="p">,</span> x2<span class="p">,</span> x3<span class="p">)</span>
</span><span class="line">label <span class="o">&lt;-</span> rep<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span> each <span class="o">=</span> <span class="m">100</span><span class="p">)</span>
</span><span class="line">dataSet3 <span class="o">&lt;-</span> data.frame<span class="p">(</span>x <span class="o">=</span> all_x<span class="p">,</span> label <span class="o">=</span> label<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下面开始绘制箱线图：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">boxplot<span class="p">(</span>dataSet3<span class="o">$</span>x<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a38/boxplot1.png" alt="plot of chunk boxplot" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## 考虑类别</span>
</span><span class="line">boxplot<span class="p">(</span>x <span class="o">~</span> label<span class="p">,</span> data <span class="o">=</span> dataSet3<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a38/boxplot2.png" alt="plot of chunk boxplot" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R语言绘图2：基础图形1]]></title>
    <link href="http://jackycode.github.io/blog/2014/05/29/basic-graph1/"/>
    <updated>2014-05-29T14:50:05+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/05/29/basic-graph1</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical37.jpg" alt="artical 37" />
<!-- more --></p>

<p>图片为本文中的某一张~~</p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h3 id="section">一、 饼图</h3>
<hr />

<p>饼图，简单来说，就是将一个圆（或者圆饼）按分类变量分成几块，每一块所占的面积比例就是相对应的变量在总体中所占的比例。</p>

<p>饼图在统计上，其实并不被看好。一般都会推荐使用条形图去代替，因为相比较面积，长度更能让人产生直观的判断。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## 构造一批数据</span>
</span><span class="line">year <span class="o">&lt;-</span> <span class="m">2001</span><span class="o">:</span><span class="m">2010</span>
</span><span class="line">set.seed<span class="p">(</span><span class="m">1234</span><span class="p">)</span>
</span><span class="line">counts <span class="o">&lt;-</span> sample<span class="p">(</span><span class="m">100</span><span class="o">:</span><span class="m">500</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="c1">## 绘图 在同一张画布上绘制4幅图，对于`par`的使用，可以`?par`</span>
</span><span class="line">par<span class="p">(</span>mfrow <span class="o">=</span> c<span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="c1">### 1</span>
</span><span class="line">pie<span class="p">(</span>counts<span class="p">,</span> labels <span class="o">=</span> year<span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="c1">### 2</span>
</span><span class="line">pie<span class="p">(</span>counts<span class="p">,</span> labels <span class="o">=</span> year<span class="p">,</span> col <span class="o">=</span> gray<span class="p">(</span>seq<span class="p">(</span><span class="m">0.1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> length <span class="o">=</span> <span class="m">10</span><span class="p">)),</span> clockwise <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="c1">### 3</span>
</span><span class="line">lb <span class="o">&lt;-</span> paste<span class="p">(</span>year<span class="p">,</span> counts<span class="p">,</span> sep <span class="o">=</span> <span class="s">&quot;:&quot;</span><span class="p">)</span>
</span><span class="line">pie<span class="p">(</span>counts<span class="p">,</span> labels <span class="o">=</span> lb<span class="p">,</span> col <span class="o">=</span> rainbow<span class="p">(</span><span class="m">10</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="c1">### 4</span>
</span><span class="line">library<span class="p">(</span>plotrix<span class="p">)</span>
</span><span class="line">pie3D<span class="p">(</span>counts<span class="p">,</span> labels <span class="o">=</span> year<span class="p">,</span> explode <span class="o">=</span> <span class="m">0.1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a37/1.png" alt="plot of chunk 1" /></p>

<h3 id="section-1">二、 条形图</h3>
<hr />

<p>刚才我们就提到，很多时候，我们会使用条形图替代饼图。实际上，<strong>条形图就是通过垂直或者水平的条形去展示分类变量的频数</strong>。</p>

<p>对于上面的数据，可以绘制：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">par<span class="p">(</span>mfrow <span class="o">=</span> c<span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">))</span>
</span><span class="line">barplot<span class="p">(</span>counts<span class="p">,</span> names.arg <span class="o">=</span> year<span class="p">)</span>
</span><span class="line">barplot<span class="p">(</span>counts<span class="p">,</span> names.arg <span class="o">=</span> year<span class="p">,</span> horiz <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
</span><span class="line">barplot<span class="p">(</span>counts<span class="p">,</span> names.arg <span class="o">=</span> year<span class="p">,</span> col <span class="o">=</span> rainbow<span class="p">(</span><span class="m">10</span><span class="p">))</span>
</span><span class="line">barplot<span class="p">(</span>counts<span class="p">,</span> names.arg <span class="o">=</span> year<span class="p">,</span> col <span class="o">=</span> grey<span class="p">(</span>seq<span class="p">(</span><span class="m">0.1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> length <span class="o">=</span> <span class="m">10</span><span class="p">)),</span> horiz <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a37/2.png" alt="plot of chunk 2" /></p>

<p>当每一年有两个变量指标时，可以绘制堆砌条形图和分组条形图：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## 构造新的数据</span>
</span><span class="line">set.seed<span class="p">(</span><span class="m">4321</span><span class="p">)</span>
</span><span class="line">counts2 <span class="o">&lt;-</span> sample<span class="p">(</span><span class="m">100</span><span class="o">:</span><span class="m">500</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
</span><span class="line">count <span class="o">&lt;-</span> cbind<span class="p">(</span>c1 <span class="o">=</span> counts<span class="p">,</span> c2 <span class="o">=</span> counts2<span class="p">)</span>
</span><span class="line">rownames<span class="p">(</span>count<span class="p">)</span> <span class="o">&lt;-</span> year
</span><span class="line">
</span><span class="line"><span class="c1">##</span>
</span><span class="line">par<span class="p">(</span>mfrow <span class="o">=</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span>
</span><span class="line">barplot<span class="p">(</span>count<span class="p">,</span> col <span class="o">=</span> rainbow<span class="p">(</span><span class="m">10</span><span class="p">),</span> legend <span class="o">=</span> rownames<span class="p">(</span>count<span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a37/31.png" alt="plot of chunk 3" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">barplot<span class="p">(</span>count<span class="p">,</span> col <span class="o">=</span> rainbow<span class="p">(</span><span class="m">10</span><span class="p">),</span> besid <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> legend <span class="o">=</span> rownames<span class="p">(</span>count<span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a37/32.png" alt="plot of chunk 3" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R语言绘图1：绘图基础]]></title>
    <link href="http://jackycode.github.io/blog/2014/05/24/basic-plotting-tools/"/>
    <updated>2014-05-24T14:48:02+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/05/24/basic-plotting-tools</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical36.jpg" alt="artical 36" />
<!-- more --></p>

<p>图片为本文中的某一张~~</p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>以数字和文字展示统计分析的结果，很多时候并不直观，也不能吸引人！而且，从数字和文字中寻找规律、异常等等的东西也并不容易。但是，对于图形来说，这些就容易解决得多了。</p>

<p>图形的作用不言而喻，就不想多说了。R语言具有强大的绘图功能，这篇就从最基础的绘图工具讲起，谈谈如何在R中绘制各种各样的图形。</p>

<h4 id="section">一、点</h4>
<hr />

<p>散点图，无论是在处理数据之前，还是在处理数据的过程中，它都显得非常的重要。在R语言中，绘制散点图非常简单，这就需要使用到函数<strong><code>plot()</code></strong>。</p>

<p>构造以下的数据以作演示使用：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">set.seed<span class="p">(</span><span class="m">1234</span><span class="p">)</span>
</span><span class="line">x <span class="o">&lt;-</span> sample<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">100</span><span class="p">,</span> <span class="m">80</span><span class="p">,</span> replace <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
</span><span class="line">y <span class="o">&lt;-</span> <span class="m">2</span> <span class="o">*</span> x <span class="o">+</span> <span class="m">20</span> <span class="o">+</span> rnorm<span class="p">(</span><span class="m">80</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h6 id="section-1">1. 首先绘制一个最简单的散点图：</h6>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">plot<span class="p">(</span>x <span class="o">=</span> x<span class="p">,</span> y <span class="o">=</span> y<span class="p">)</span>  <span class="c1">## 或者使用: plot(x, y)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/2.png" alt="plot of chunk 2" /></p>

<p>其中，<code>x = x</code>左侧的<code>x</code>表示横坐标，右侧的是数据名，<code>y</code>的相同。当然，左侧的<code>x</code>和<code>y</code>都是可以省略的。也可以使用<code>plot(&lt;formula&gt;)</code>这样的形式去绘制散点图：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">plot<span class="p">(</span>y <span class="o">~</span> x<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/3.png" alt="plot of chunk 3" /></p>

<h5 id="section-2">2. 添加标题和标签</h5>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">plot<span class="p">(</span>x<span class="p">,</span> y<span class="p">,</span> xlab <span class="o">=</span> <span class="s">&quot;name of x&quot;</span><span class="p">,</span> ylab <span class="o">=</span> <span class="s">&quot;name of y&quot;</span><span class="p">,</span> main <span class="o">=</span> <span class="s">&quot;Scatter Plot&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/4.png" alt="plot of chunk 4" /></p>

<h5 id="section-3">3. 设置坐标界限</h5>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## 可先用以下函数查看x和y的取值范围 range(x) range(y)</span>
</span><span class="line">plot<span class="p">(</span>x<span class="p">,</span> y<span class="p">,</span> xlab <span class="o">=</span> <span class="s">&quot;name of x&quot;</span><span class="p">,</span> ylab <span class="o">=</span> <span class="s">&quot;name of y&quot;</span><span class="p">,</span> main <span class="o">=</span> <span class="s">&quot;Scatter Plot&quot;</span><span class="p">,</span> xlim <span class="o">=</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span>
</span><span class="line">    <span class="m">100</span><span class="p">),</span> ylim <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">250</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/5.png" alt="plot of chunk 5" /></p>

<h5 id="section-4">4. 更改字符</h5>

<p>默认情形下，绘图字符为空心点，可以使用<code>pch</code>选项参数进行更改：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">plot<span class="p">(</span>x<span class="p">,</span> y<span class="p">,</span> xlab <span class="o">=</span> <span class="s">&quot;name of x&quot;</span><span class="p">,</span> ylab <span class="o">=</span> <span class="s">&quot;name of y&quot;</span><span class="p">,</span> main <span class="o">=</span> <span class="s">&quot;Scatter Plot&quot;</span><span class="p">,</span> xlim <span class="o">=</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span>
</span><span class="line">    <span class="m">100</span><span class="p">),</span> ylim <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">250</span><span class="p">),</span> pch <span class="o">=</span> <span class="m">19</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/6.png" alt="plot of chunk 6" /></p>

<p><code>pch</code>的取值与其对应的图形字符，也可以使用<code>plot</code>绘制：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">a <span class="o">&lt;-</span> rep<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">,</span> each <span class="o">=</span> <span class="m">5</span><span class="p">)</span>
</span><span class="line">b <span class="o">&lt;-</span> rep<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span><span class="line">plot<span class="p">(</span>a<span class="p">,</span> b<span class="p">,</span> pch <span class="o">=</span> <span class="m">1</span><span class="o">:</span><span class="m">25</span><span class="p">)</span>
</span><span class="line">text<span class="p">(</span>a<span class="p">,</span> b<span class="p">,</span> <span class="m">1</span><span class="o">:</span><span class="m">25</span><span class="p">,</span> pos <span class="o">=</span> <span class="m">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/7.png" alt="plot of chunk 7" /></p>

<h5 id="section-5">5. 更改颜色</h5>

<p>默认情况下，R绘制的图像是黑白的。但其实，R中有若干和颜色相关的参数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">plot<span class="p">(</span>x<span class="p">,</span> y<span class="p">,</span> main <span class="o">=</span> <span class="s">&quot;Plot&quot;</span><span class="p">,</span> sub <span class="o">=</span> <span class="s">&quot;Scatter Plot&quot;</span><span class="p">,</span> col <span class="o">=</span> <span class="s">&quot;red&quot;</span><span class="p">,</span> col.axis <span class="o">=</span> <span class="s">&quot;green&quot;</span><span class="p">,</span>
</span><span class="line">    col.lab <span class="o">=</span> <span class="s">&quot;blue&quot;</span><span class="p">,</span> col.main <span class="o">=</span> <span class="s">&quot;#999000&quot;</span><span class="p">,</span> col.sub <span class="o">=</span> <span class="s">&quot;#000999&quot;</span><span class="p">,</span> fg <span class="o">=</span> <span class="s">&quot;gray&quot;</span><span class="p">,</span>
</span><span class="line">    bg <span class="o">=</span> <span class="s">&quot;white&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/8.png" alt="plot of chunk 8" /></p>

<p>其中：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">参数</th>
      <th style="text-align: center">作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">col</td>
      <td style="text-align: center">绘图字符的颜色</td>
    </tr>
    <tr>
      <td style="text-align: center">col.axis</td>
      <td style="text-align: center">坐标轴文字颜色</td>
    </tr>
    <tr>
      <td style="text-align: center">col.lab</td>
      <td style="text-align: center">坐标轴标签颜色</td>
    </tr>
    <tr>
      <td style="text-align: center">col.main</td>
      <td style="text-align: center">标题颜色</td>
    </tr>
    <tr>
      <td style="text-align: center">col.sub</td>
      <td style="text-align: center">副标题颜色</td>
    </tr>
    <tr>
      <td style="text-align: center">fg</td>
      <td style="text-align: center">前景色</td>
    </tr>
    <tr>
      <td style="text-align: center">bg</td>
      <td style="text-align: center">背景色</td>
    </tr>
  </tbody>
</table>

<h5 id="section-6">6. 更改尺寸</h5>

<p>与颜色类似，存在若干参数可以用来设置图形中元素的尺寸，而且与上表中设置颜色的参数相对应，只需将<code>col</code>更换成<code>cex</code>即可：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">plot<span class="p">(</span>x<span class="p">,</span> y<span class="p">,</span> main <span class="o">=</span> <span class="s">&quot;Plot&quot;</span><span class="p">,</span> sub <span class="o">=</span> <span class="s">&quot;Scatter Plot&quot;</span><span class="p">,</span> cex <span class="o">=</span> <span class="m">0.5</span><span class="p">,</span> cex.axis <span class="o">=</span> <span class="m">1</span><span class="p">,</span> cex.lab <span class="o">=</span> <span class="m">0.8</span><span class="p">,</span>
</span><span class="line">    cex.main <span class="o">=</span> <span class="m">2</span><span class="p">,</span> cex.sub <span class="o">=</span> <span class="m">1.5</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/9.png" alt="plot of chunk 9" /></p>

<h4 id="section-7">二、线</h4>

<p>有时候，我们不仅需要散点图，更需要折线图，比如在时间序列当中：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">t <span class="o">&lt;-</span> <span class="m">1</span><span class="o">:</span><span class="m">50</span>
</span><span class="line">set.seed<span class="p">(</span><span class="m">1234</span><span class="p">)</span>
</span><span class="line">v <span class="o">&lt;-</span> rnorm<span class="p">(</span><span class="m">50</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
</span><span class="line">plot<span class="p">(</span>t<span class="p">,</span> v<span class="p">,</span> type <span class="o">=</span> <span class="s">&quot;l&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/10.png" alt="plot of chunk 10" /></p>

<h5 id="section-8">1. 更改线条类型</h5>

<p>R中提供了很多类型的线条，可以通过<code>lty</code>选项来设定，如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">a <span class="o">&lt;-</span> c<span class="p">()</span>
</span><span class="line">plot<span class="p">(</span>a<span class="p">,</span> xlim <span class="o">=</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">),</span> ylim <span class="o">=</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">6</span><span class="p">),</span> xlab <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> ylab <span class="o">=</span> <span class="s">&quot;lty&quot;</span><span class="p">)</span>
</span><span class="line"><span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    abline<span class="p">(</span>h <span class="o">=</span> i<span class="p">,</span> lty <span class="o">=</span> i<span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/11.png" alt="plot of chunk 11" /></p>

<h5 id="section-9">2. 更改颜色</h5>

<p>与前面更改点的颜色方法相同！</p>

<h5 id="section-10">3. 线条宽度</h5>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">plot<span class="p">(</span>t<span class="p">,</span> v<span class="p">,</span> type <span class="o">=</span> <span class="s">&quot;l&quot;</span><span class="p">,</span> lwd <span class="o">=</span> <span class="m">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/12.png" alt="plot of chunk 12" /></p>

<h5 id="section-11">4. 点与线</h5>

<p>有时候，我们还需要将点突出出来，此时需要利用<code>type</code>选项：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">plot<span class="p">(</span>t<span class="p">,</span> v<span class="p">,</span> type <span class="o">=</span> <span class="s">&quot;b&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/13.png" alt="plot of chunk 13" /></p>

<p><code>type</code>选项可以指定<code>plot()</code>函数绘制的类型，可以使用<code>help(plot)</code>查看。</p>

<h4 id="section-12">三、散点图与平滑线</h4>

<p>在做线性回归时，我们常常会在散点图中添加一条拟合直线以查看效果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">model <span class="o">&lt;-</span> lm<span class="p">(</span>y <span class="o">~</span> x<span class="p">)</span>
</span><span class="line">plot<span class="p">(</span>x<span class="p">,</span> y<span class="p">)</span>
</span><span class="line">abline<span class="p">(</span>model<span class="p">,</span> col <span class="o">=</span> <span class="s">&quot;blue&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/14.png" alt="plot of chunk 14" /></p>

<p>有时候，我们需要在散点图上画一条拟合的平滑线，一般使用loess：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">plot<span class="p">(</span>x<span class="p">,</span> y<span class="p">)</span>
</span><span class="line">model_loess <span class="o">&lt;-</span> loess<span class="p">(</span>y <span class="o">~</span> x<span class="p">)</span>
</span><span class="line">fit <span class="o">&lt;-</span> fitted<span class="p">(</span>model_loess<span class="p">)</span>
</span><span class="line">ord <span class="o">&lt;-</span> order<span class="p">(</span>x<span class="p">)</span>
</span><span class="line">lines<span class="p">(</span>x<span class="p">[</span>ord<span class="p">],</span> fit<span class="p">[</span>ord<span class="p">],</span> lwd <span class="o">=</span> <span class="m">2</span><span class="p">,</span> lty <span class="o">=</span> <span class="m">2</span><span class="p">,</span> col <span class="o">=</span> <span class="s">&quot;blue&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/15.png" alt="plot of chunk 15" /></p>

<p>当然，在R语言中要实现上面的图形有很多简单地方法，这里介绍两个：</p>

<h5 id="carscatterplot">1. 使用<code>car</code>包中的<code>scatterplot()</code>函数</h5>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">library<span class="p">(</span>car<span class="p">)</span>
</span><span class="line">scatterplot<span class="p">(</span>y <span class="o">~</span> x<span class="p">,</span> spread <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span> lty <span class="o">=</span> <span class="m">1</span><span class="p">,</span> lwd <span class="o">=</span> <span class="m">2</span><span class="p">,</span> smoother.args <span class="o">=</span> list<span class="p">(</span>lty <span class="o">=</span> <span class="m">2</span><span class="p">,</span>
</span><span class="line">    lwd <span class="o">=</span> <span class="m">2</span><span class="p">),</span> smoother <span class="o">=</span> loessLine<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/16.png" alt="plot of chunk 16" /></p>

<p>其中，直线为线性拟合，虚线为loess曲线拟合，边界为箱线图！</p>

<p>在函数中<code>smoother.args</code>选项指定曲线拟合的参数；<code>smoother</code>选项指定是否使用曲线拟合，以及用什么方法进行曲线拟合。当然，如果不需要曲线平滑拟合，那么可以将<code>smoother = FALSE</code>。</p>

<h5 id="ggplot2">2. 使用<code>ggplot2</code>包</h5>

<p><code>ggplot2</code>是学习R语言制图的一座大山，它提供了一个基于全面而连贯的语法的绘图系统。功能非常强大，而且弥补了R中自带图形绘制的很多缺点。唯一的问题，学习<code>ggplot2</code>的成本比较大，需要理解很多概念，也需要学习新的语法。</p>

<p><strong>如果你是刚刚入门R语言，对于R语言基础的绘图工具还不是很熟的话，建议先跳过这一段，不要去弄懂其中的意思，试试效果就可以了！等对R语言基础绘图有了一定的了解之后，再来学习ggplot2，个人觉得会比较好一些！</strong></p>

<p><strong><em>当然，如果你跟我一样喜欢折腾，不怕纠结，我不介意你一块学！不过，你遇到什么样的问题，那我就不保证了，反正我当时好长一段时间是蛮惨的！</em></strong></p>

<p>使用这个包，实现的方法一般有两种，就是使用<code>qplot()</code>函数和<code>ggplot()</code>函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">qplot<span class="p">(</span>x<span class="p">,</span> y<span class="p">,</span> geom <span class="o">=</span> c<span class="p">(</span><span class="s">&quot;point&quot;</span><span class="p">,</span> <span class="s">&quot;smooth&quot;</span><span class="p">),</span> method <span class="o">=</span> <span class="s">&quot;lm&quot;</span><span class="p">,</span> se <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span> <span class="o">+</span> geom_smooth<span class="p">(</span>method <span class="o">=</span> <span class="s">&quot;loess&quot;</span><span class="p">,</span>
</span><span class="line">    color <span class="o">=</span> <span class="s">&quot;red&quot;</span><span class="p">,</span> se <span class="o">=</span> <span class="kc">FALSE</span><span class="p">,</span> lty <span class="o">=</span> <span class="m">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/17.png" alt="plot of chunk 17" /></p>

<p>或者：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">dataSet <span class="o">&lt;-</span> data.frame<span class="p">(</span>x <span class="o">=</span> x<span class="p">,</span> y <span class="o">=</span> y<span class="p">)</span>
</span><span class="line">ggplot<span class="p">(</span>aes<span class="p">(</span>x<span class="p">,</span> y<span class="p">),</span> data <span class="o">=</span> dataSet<span class="p">)</span> <span class="o">+</span> geom_point<span class="p">()</span> <span class="o">+</span> geom_smooth<span class="p">(</span>method <span class="o">=</span> <span class="s">&quot;lm&quot;</span><span class="p">,</span>
</span><span class="line">    color <span class="o">=</span> <span class="s">&quot;green&quot;</span><span class="p">,</span> lty <span class="o">=</span> <span class="m">1</span><span class="p">,</span> se <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span> <span class="o">+</span> geom_smooth<span class="p">(</span>method <span class="o">=</span> <span class="s">&quot;loess&quot;</span><span class="p">,</span> color <span class="o">=</span> <span class="s">&quot;red&quot;</span><span class="p">,</span>
</span><span class="line">    lty <span class="o">=</span> <span class="m">2</span><span class="p">,</span> se <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://jackycode.github.io/images/a36/18.png" alt="plot of chunk 18" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习17:因子分析2]]></title>
    <link href="http://jackycode.github.io/blog/2014/05/19/factor-analysis2/"/>
    <updated>2014-05-19T15:00:02+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/05/19/factor-analysis2</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical35.jpg" alt="artical 35" />
<!-- more --></p>

<p>图片来源于<a href="http://software.ssri.co.jp/statweb2/column/column0811.html">网址</a></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>这两天来了个同学，大家聚了聚，我也乘机休息了两天（好奢侈！）。这两天属于什么都没有写，就翻看了两本书。一本是二月河的<a href="http://www.amazon.cn/gp/product/B0032K0X6Q/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">康熙大帝</a>，另外一本是<a href="http://www.ituring.com.cn/book/894">推荐系统实践</a>，这本书的电子版，图灵正在打折，有兴趣可以买本看看。</p>

<hr />

<p>好了，不废话了，下面就接着上一篇讲的继续！上一篇简单介绍了因子分析的一些概念，以及最基础的因子模型：<strong>正交因子模型</strong>。那么这一篇，就来说说正交因子模型的<strong>参数估计问题</strong>。</p>

<p>对于一组p维样本，有n个观测值：<script type="math/tex">x_1, x_2, \dots, x_n</script>，则其均值和协方差矩阵可以使用样本均值和样本协方差矩阵来估计：</p>

<script type="math/tex; mode=display"> \hat{\mu} = \overline{x} = \frac{1}{n} {\sum_{i=1}^{n} x_i} </script>

<script type="math/tex; mode=display"> \hat{\Sigma} = S = \frac{1}{n-1} {\sum_{i=1}^{n} (x_i-\overline{x})(x_i-\overline{x})'} </script>

<p>在因子模型中，需要估计的有两个参数：<strong>因子载荷矩阵</strong><script type="math/tex">A=(a_{ij}:p \times m)</script>以及<strong>特殊方差矩阵</strong><script type="math/tex">D = diag(\sigma_1^2, \sigma_2^2, \dots, \sigma_p^2)</script>。</p>

<hr />

<h4 id="section">1. 主成分法</h4>
<hr />

<p>主成分法的思想取自于主成分分析，即是取出前m个成分作为主成分，然后以此来得到因子载荷矩阵的估计；然后再以协方差阵和因子载荷矩阵为条件，直接推出特殊方差矩阵。具体如下：</p>

<ol>
  <li>求出协方差矩阵<script type="math/tex">S</script>的特征值：<script type="math/tex">\hat{\lambda}_1 \geqslant \hat{\lambda}_2 \geqslant \dots \geqslant \hat{\lambda}_p \geqslant 0</script>，其对应的特征向量为：<script type="math/tex">\hat{t}_1, \hat{t}_2, \dots, \hat{t}_p</script>。</li>
  <li>选一个较小因子数<script type="math/tex">m</script>，并且使得前m项累计贡献率<script type="math/tex">\frac{\sum_{i=1}^{m} \hat{\lambda}_i}{\sum_{i=1}^{p} \hat{\lambda}_i} </script>高于设定值。</li>
  <li>将协方差矩阵<script type="math/tex">S</script>做这样的近似：<script type="math/tex">S = \sum_{i=1}^{m} \hat{\lambda}_i + \sum_{i=m+1}^{p} \hat{\lambda}_i \approx \sum_{i=1}^{m} \hat{\lambda}_i + \hat{D} := \hat{A}\hat{A}' + \hat{D} </script></li>
</ol>

<p>其中，<script type="math/tex">A = (\sqrt{\hat{\lambda}_1}t_1, \sqrt{\hat{\lambda}_2}t_2, \dots, \sqrt{\hat{\lambda}_m}t_m) </script>,<script type="math/tex">\hat{D} = diag(\hat{\sigma}_1^2, \hat{\sigma}_2^2, \dots, \hat{\sigma}_p^2) </script>,<script type="math/tex">\hat{\sigma}_i^2 = s_{ii} - \sum_{j=1}^{m} \hat{a}_{ij}^2 </script></p>

<p>从上述的过程来看，我们是使用了一种近似的方法估计出了<script type="math/tex">A</script>和<script type="math/tex">D</script>，那么这就有一个<strong>残差矩阵</strong><script type="math/tex">S - (\hat{A}\hat{A}' + \hat{D}) </script>，显然这个矩阵的对角线元素为0。既然是一种近似，那么，如果这个残差矩阵的非对角线元素都非常小的时候，我们就可以认为取<script type="math/tex">m</script>个因子的模型就可以很好地解释或者是拟合原始的数据了。</p>

<hr />

<h4 id="section-1">2. 主因子法</h4>
<hr />

<p>对于因子模型，我们先对原始向量进行标准化，则有：<script type="math/tex"> R = AA' + D</script>。取<strong>约相关矩阵</strong><script type="math/tex">R^* = R - D = AA'</script>，假设特殊方差<script type="math/tex">\sigma_i^2</script>的一个估计值<script type="math/tex">\hat{\sigma}^2</script>为初始估计，则有约相关矩阵的估计值为：</p>

<p><img src="http://jackycode.github.io/images/a35/eq2_1.png" alt="" /></p>

<p>其中<script type="math/tex">\hat{R}</script>为样本相关矩阵，<script type="math/tex">\hat{D} = diag(\hat{\sigma^2_1},\hat{\sigma_2^2}, \dots, \hat{\sigma_p^2}) </script>, <script type="math/tex">\hat{h_i^2} = 1 - \hat{\sigma_i^2} </script>为<script type="math/tex">h_i^2</script>的初始估计。</p>

<p>计算<script type="math/tex">\hat{R}^*</script>的特征值，取足够小，但累计贡献率达到要求的m：<script type="math/tex">\hat{\lambda^*_1} \geqslant \hat{\lambda^*_2} \geqslant \dots \geqslant \hat{\lambda^*_m} > 0 </script>，其对应的特征向量为：<script type="math/tex">\hat{t^*_1}, \hat{t^*_2}, \dots, \hat{t^*_m}</script>，则得到 <script type="math/tex">A</script> 的估计值：</p>

<script type="math/tex; mode=display"> \hat{A} = (\sqrt{\hat{\lambda^*_1}}t^*_1, \sqrt{\hat{\lambda^*_2}}t^*_2, \dots, \sqrt{\hat{\lambda^*_m}}t^*_m ) </script>

<p>那么<script type="math/tex">\sigma^2_i</script>的最终估计为： <script type="math/tex"> \hat{\sigma_i^2} = 1-\hat{h_i^2} = 1 - \sum_{j=1}^{m} \hat{a_{ij}^2} </script>。</p>

<p>可以看到，这是一个可以迭代的过程，我们可以一直迭代，直到结果达到稳定为止！从过程来看，这里其实也是利用了主成分，因而，主因子法也是主成分法的一种修正！</p>

<p>那么接下来的问题就是，这个特殊方差<script type="math/tex">\sigma^2_i</script>的初始估计值应该如何取呢？最常用的取法：<script type="math/tex"> \hat{\sigma_i^2} = 1/r^{ii} </script>, 其中<script type="math/tex"> r^{ii} </script>为<script type="math/tex">\hat{R}^{-1}</script>对角线元素的第<script type="math/tex">i</script>个。</p>

<hr />

<h4 id="section-2">3. 极大似然法</h4>
<hr />

<p>使用极大似然估计，那么就肯定需要使用样本的分布，这里我们假定公共因子<script type="math/tex">f \sim N_m(0, I) </script>，特殊因子<script type="math/tex"> \varepsilon \sim N_p(0, D) </script>，并且相互独立！这里的假设其实就是来源于模型的正交性假设，只不过是将正交性假设进一步限定，假设它们都是属于多元正态分布！</p>

<p>有了上述假设，通过模型就可以知道<script type="math/tex">x \sim N_p(\mu, \Sigma) </script>，有了这个就可以计算样本的似然函数了，这里涉及到较为复杂的矩阵计算，不想多说，有兴趣的话可以查找一些资料；或者学习一下线性模型中关于矩阵求导的知识，然后自己推导一下。</p>

<p>一般情况下，极大似然法使用得并不太多，因为这个方法是算不出显式解的，在没有限制条件的情况下，解也并不唯一确定！但是如果是在因子分部可以明显知道的情况下，使用这个方法就比较好了！</p>

<hr />

<h3 id="section-3">总结</h3>
<hr />

<p>到这边，对于基础的因子模型就介绍结束了。回顾一下，主要就是介绍了正交因子模型以及它的参数估计问题。但是，到这里，我们还没有说到模型中的公共因子如何解释这个问题！对于这个问题的解释，通常结合实际的问题，需要一定的专业知识和经验，然后才能给每个公共因子给出一个实际意义。而且，公共因子的解释，在很大程度上也依赖于因子模型中因子载荷矩阵的元素结构！这个时候就会牵扯出因子分析中其它的一些问题：<strong>因子旋转</strong>和<strong>因子得分</strong>。因为这两个问题涉及到一些比较复杂的数学知识，我不能够在清减数学的情况下说好它，如果单说怎么用，我觉得没有必要，所以暂时并不打算介绍这两个问题。有兴趣的，可以翻阅一些多元统计的书籍，一般都会有讲。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习16:因子分析1]]></title>
    <link href="http://jackycode.github.io/blog/2014/05/14/factor-analysis1/"/>
    <updated>2014-05-14T16:05:45+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/05/14/factor-analysis1</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical34.jpg" alt="artical 34" />
<!-- more --></p>

<p>图片来源于<a href="http://software.ssri.co.jp/statweb2/column/column0811.html">网址</a></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>前一篇介绍的主成分分析(PCA)，是一种降维技术；这一篇介绍的因子分析也是一种降维的方法，不仅如此，还可以将因子分析看作是主成分分析的一种推广和发展。与之主成分分析相比较，因子分析更为灵活，对变量降维后的解释能够更加清楚。</p>

<p>但因子分析和主成分分析有非常多的不同点。</p>

<ol>
  <li>主成分分析不能作为一个模型来描述，主成分是观测变量的线性组合；</li>
  <li>因子分析需要构造因子模型，观测的原始变量是因子的线性组合。</li>
</ol>

<hr />

<h4 id="section">初窥</h4>
<hr />

<p>在介绍因子模型之前，可以先看看这个因子分析到底是要干什么，以及是怎么干的！</p>

<p>在二维空间中，主成分分析，它想做的是寻找一组新的变量<script type="math/tex">y_1,y_2</script>，用它去替代原来的变量<script type="math/tex">x_1,x_2</script>，并且满足<script type="math/tex">y_1</script>和<script type="math/tex">y_2</script>这两个变量都是<script type="math/tex">x_1,x_2</script>两个变量的线性组合！即：</p>

<p><img src="http://jackycode.github.io/images/a34/eq1.jpg" alt="" /></p>

<p>而在因子模型中，我们需要做的跟此不同。我们需要找到一组潜在变量(不可观测)，用这组潜在变量的线性组合去表示原始变量<script type="math/tex">x_1,x_2</script>。这里假设有1个潜在变量<script type="math/tex">f_1</script>，那么因子模型可以描述成：</p>

<p><img src="http://jackycode.github.io/images/a34/eq2.png" alt="" /></p>

<p>其中，<script type="math/tex">f_1</script>就是因子，称为<strong>公共因子</strong>；<script type="math/tex">a_{ij}</script>称之为变量<script type="math/tex">x_i</script>在因子<script type="math/tex">f_j</script>上的<strong>载荷</strong>；<script type="math/tex">\mu_i</script>是<script type="math/tex">x_i</script>的均值；<script type="math/tex">\varepsilon_i</script>为特殊因子，即不能被公共因子解释的部分。</p>

<hr />

<h4 id="section-1">正交因子模型</h4>
<hr />

<p>首先看看最基础的因子模型，就是正交假设下的因子模型：</p>

<p><img src="http://jackycode.github.io/images/a34/eq3.png" alt="" /></p>

<p>在给出假定之前，我们先将上面式子转换成矩阵形式：</p>

<script type="math/tex; mode=display"> x = \mu + Af + \varepsilon </script>

<p>其中，<script type="math/tex">x = (x_1, x_2, \dots, x_p)'</script>，<script type="math/tex">\mu = (\mu_1, \mu_2, \dots, \mu_p)'</script>为均值向量，<script type="math/tex">\varepsilon = (\varepsilon_1, \varepsilon_2, \dots, \varepsilon_p)'</script>为特殊因子向量, <script type="math/tex">f = (f_1, f_2, \dots, f_p)'</script>为公共因子向量，<script type="math/tex"> A = (a_{ij}):p \times m </script>为载荷矩阵。那么我们就可以给出如下的正交假设：</p>

<p><img src="http://jackycode.github.io/images/a34/eq4.png" alt="" /></p>

<p>在这样的假定下，我们首先来计算一下，原始变量<script type="math/tex">x</script>的协方差：</p>

<script type="math/tex; mode=display"> \Sigma = V(x) = V(Af+\varepsilon) = Cov(Af+\varepsilon,Af+\varepsilon) </script>

<p>又：<script type="math/tex">Cov(Af+\varepsilon,Af+\varepsilon)=AV(f)A'+ACov(f,\varepsilon)+Cov(\varepsilon,f)A'+V(\varepsilon)</script></p>

<p>由于<script type="math/tex">V(f) = I, Cov(f, \varepsilon) = Cov(\varepsilon, f) = 0</script>，所以：</p>

<script type="math/tex; mode=display"> \Sigma = AA' + V(\varepsilon) = AA' + D </script>

<p><strong>显然，我们要处理正交因子模型，最重要的就是求解<script type="math/tex">A,D</script>的估计值，那么这里就给出了这两个量与原始变量的协方差矩阵间的关系。</strong></p>

<p><strong>那么我们开始所说的，因子分析也是一种降维手段体现在哪里呢？</strong>这个就体现在，公共因子的数量上，当公共因子的数量少于原始变量的数量时，使用因子去解释原始变量就达到了一种降维的目的！</p>

<hr />

<p><strong><em>载荷矩阵</em></strong></p>

<p>显然，载荷矩阵<script type="math/tex">A</script>是我们关心的一个重点。首先，我们想弄明白<script type="math/tex">A</script>中的元素<script type="math/tex">a_{ij}</script>是否有什么具体的含义：</p>

<script type="math/tex; mode=display">Cov(x_i,f_j)=Cov(\sum_{k=1}^{m}a_{ik}f_k + \varepsilon_i, f_j) =a_{ij}Cov(f_j,f_j) = a_{ij} </script>

<p>那么可以看到，<script type="math/tex">a_{ij}</script>是<script type="math/tex">x_i</script>和<script type="math/tex">f_j</script>之间的协方差函数。</p>

<p>经过上面的计算，我们容易得到：</p>

<script type="math/tex; mode=display">V(x_i) = a_{i1}^2 + a_{i2}^2 + \dots + a_{1m}^2 + V(\varepsilon_i)</script>

<p>记<script type="math/tex">h_i^2 = \sum_{j=1}^{m}a_{ij}^2</script>，那么上式可转化为：</p>

<script type="math/tex; mode=display"> (V(x_i) =) \sigma_{ii} = h_i^2 + \sigma_i^2, i=1,2,\dots,p</script>

<p>这样就将<script type="math/tex">x_i</script>的方差进行了一个分解，一部分由公共因子解释，即<script type="math/tex">h_i^2</script>，称为<strong>共性方差</strong>；另一部分由特殊因子解释，即<script type="math/tex">\sigma_i^2</script>，称为<strong>特殊方差</strong>。</p>

<hr />

<p>至此，因子分析的基础模型就介绍完了，下面剩下的就是如何去进行参数的估计，这一般有三种方法：主成分法、主因子法以及极大似然法。下一篇，我们就来详细说说因子分析的参数估计问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习15: 主成分分析]]></title>
    <link href="http://jackycode.github.io/blog/2014/05/11/principal-components/"/>
    <updated>2014-05-11T11:35:10+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/05/11/principal-components</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical33.jpg" alt="artical 33" />
<!-- more --></p>

<p>图片为：本文实例数据得到的，前两个主成分的散点图！</p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>在之前<a href="http://jackycode.github.io/blog/2014/04/02/linear-regression3/">线性回归3</a>提到多重共线性问题，当时说了一些解决这个问题的办法，其中一种就是今天要说的<strong>主成分分析</strong>。</p>

<p><strong>主成分分析</strong>，Principal Components Analysis，简称PCA，是变量选择的一种方法。其一般的目的就是：变量的降维和主成分的解释！当主成分用于聚类或者回归，这个时候就是在做变量的降维；而当用来分析变量，尤其是使用前两个主成分进行散点图的绘制时，此时就是在对变量利用主成分做出一些解释。在了解主成分分析的原理之后，相信对这两个目的就可以很容易直观的理解了！</p>

<hr />

<h4 id="section">一、原理初窥</h4>
<hr />

<p>在用数学公式和概率统计知识推导其原理之前，不妨先直观地看看主成分分析到底是要干嘛，以及大致是怎么干的！</p>

<p>我们就用两个变量来说这个问题，变量分别记作<script type="math/tex">x_1,x_2</script>。那么，我们先画个散点图吧，也许它们的散点图是这个样子的：</p>

<p><img src="http://jackycode.github.io/images/a33/images1.jpg" alt="" /></p>

<p>我们可以看到，这两个变量明显呈现一种线性关系，如果在做线性回归时，将这两个变量都用作自变量，然后对某一个因变量进行线性拟合，那必定会存在一些问题。那么主成分分析是要做什么呢？其实主成分分析就是要寻找变量<script type="math/tex">y_1,y_2</script>去替代<script type="math/tex">x_1,x_2</script>，而且满足<script type="math/tex">y_1,y_2</script>几乎不相关，同时<script type="math/tex">y_1,y_2</script>能够保留<script type="math/tex">x_1,x_2</script>所包含的信息。</p>

<p>那么主成分分析是如何做的呢？这个时候就需要考虑旋转坐标轴，当我们像下图那样旋转过坐标轴之后，上面提出的要求就得到了实现。</p>

<p><img src="http://jackycode.github.io/images/a33/images2.jpg" alt="" /></p>

<p>从这张图我们就可以看出，数据投影到<script type="math/tex">y_1,y_2</script>两轴后，数据基本不相关，而且在<script type="math/tex">y_1</script>轴就保留了原本数据的大部分信息，<script type="math/tex">y_2</script>保留了数据的另外一部分信息。由此可见，数据越是集中在<script type="math/tex">y_1</script>轴两侧，数据映射到<script type="math/tex">y_1</script>轴后保留的信息就越多，而<script type="math/tex">y_2</script>就越少。当<script type="math/tex">y_2</script>含有的信息非常少，少到接近于0时，那么此时就到达了变量选择的目的，因为此时只要保留<script type="math/tex">y_1</script>就可以了。</p>

<hr />

<h4 id="section-1">二、原理</h4>
<hr />

<p>我们将数据映射到<script type="math/tex">y_1,y_2</script>轴，其实就是将原数据做个线性变换。利用上面的内容举个简单地例子就是：</p>

<p><img align="center" src="http://jackycode.github.io/images/a33/eq1.jpg" /></p>

<p>其中的系数满足：<script type="math/tex">a_{11}^2 + a_{21}^2=1,a_{12}^2 + a_{22}^2=1</script>。这样就可以成功地将数据投影到<script type="math/tex">y_1,y_2</script>轴。这里我们考虑更一般的情况，考虑<script type="math/tex">p</script>维的情况：</p>

<p><img align="center" src="http://jackycode.github.io/images/a33/eq2.jpg" /></p>

<p>其中<script type="math/tex">a_i=(a_{1i},a_{2i},\dots,a_{pi})', i=1,2,\dots,p</script>，且满足<script type="math/tex">a_i'a_1=1</script>。</p>

<p>下面要考虑的就是，如何选择<script type="math/tex">a_1</script>，使得<script type="math/tex">V(y_1)</script>到达最大，找到之后，<script type="math/tex">y_1</script>就是<strong>第一主成分</strong>。</p>

<p>首先，<script type="math/tex">V(y_1)=a_1' \Sigma a_1</script>，其中<script type="math/tex">\Sigma=V(x)</script>为协方差矩阵。我们知道<script type="math/tex">\Sigma</script>是非负定的，那么其所有的特征值必定都是大于等于0的，我们可以排个序：<script type="math/tex">\lambda _{ 1 }\geqslant \lambda _{ 2 }\geqslant \dots \geqslant \lambda_p \geqslant 0</script>，其对应的特征向量记为：<script type="math/tex">t_1, t_2, \dots, t_p</script>，显然这些特征向量是相互正交的。记<script type="math/tex">T=(t_1, t_2, \dots, t_p)=(t_{ik}), \Lambda=diag(\lambda_1,\lambda_2,\dots,\lambda_p)</script>。</p>

<p>那么根据谱分解就有：<script type="math/tex">\Sigma=T \Lambda T'=\sum_{i=1}^{p}\lambda_it_it_i'</script>。那么带入到<script type="math/tex">V(y_1)</script>中就有：</p>

<script type="math/tex; mode=display">V(y_1)=\sum_{i=1}^{p} \lambda_i a_1' t_it_i' a_1 = \sum_{i=1}^{p} \lambda_i(a_1't_i)^2</script>

<p>由于特征值中<script type="math/tex">\lambda_1</script>是最大的，那么就有：</p>

<script type="math/tex; mode=display">V(y_1) \leqslant \lambda_1 \sum_{i=1}^{p} (a_1't_i)^2 = \lambda_1 \sum_{i=1}^{p} {a_1't_it_i'a_1} = \lambda_1 a_1' TT'a_1 = \lambda_1</script>

<p>可以看到最终的结果是：<script type="math/tex">V(y_1) \leqslant \lambda_1</script>。那么什么时候取等号呢？取<script type="math/tex">a_1 = t_1</script>，则有：</p>

<script type="math/tex; mode=display">t_1'\Sigma t_1 = t_1' (\lambda_1t_1) = \lambda_1</script>

<p>到止为止，就可以看到。当<script type="math/tex">y_1=t_1'x</script>时就有其<script type="math/tex">V(y_1)</script>达到最大，为<script type="math/tex">\lambda_1</script>。那么此时<script type="math/tex">y_1=t_1'x</script>就是该数据第一主成分。</p>

<p>同理可以求解第二主成分直至最后。<strong>但是，在求解第二第三主成分的时候，需要注意一个新的问题：主成分之间不相关，即<script type="math/tex">Cov(y_i,y_k)=0,i \neq k</script></strong>，如何证明非常简单，我就不说了，自己动动手吧。</p>

<hr />

<h4 id="section-2">三、具体实例</h4>
<hr />

<p>我们使用R语言来做个小例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1"># 构造一个数据集</span>
</span><span class="line">set.seed<span class="p">(</span><span class="m">10</span><span class="p">)</span>
</span><span class="line">x1 <span class="o">&lt;-</span> seq<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">50</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="o">+</span> rnorm<span class="p">(</span><span class="m">25</span><span class="p">,</span> mean<span class="o">=</span><span class="m">1</span><span class="p">,</span> sd<span class="o">=</span><span class="m">1</span><span class="p">)</span>
</span><span class="line">x2 <span class="o">&lt;-</span> <span class="m">2</span><span class="o">*</span>x1 <span class="o">+</span> rnorm<span class="p">(</span><span class="m">25</span><span class="p">,</span> mean<span class="o">=</span><span class="m">1</span><span class="p">,</span> sd<span class="o">=</span><span class="m">1</span><span class="p">)</span>
</span><span class="line">x3 <span class="o">&lt;-</span> x1<span class="o">/</span><span class="m">2</span> <span class="o">+</span> x2 <span class="o">+</span> rnorm<span class="p">(</span><span class="m">25</span><span class="p">,</span> mean<span class="o">=</span><span class="m">1</span><span class="p">,</span> sd<span class="o">=</span><span class="m">1</span><span class="p">)</span>
</span><span class="line">x <span class="o">&lt;-</span> data.frame<span class="p">(</span>x1<span class="o">=</span>x1<span class="p">,</span> x2<span class="o">=</span>x2<span class="p">,</span> x3<span class="o">=</span>x3<span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="c1"># 计算协方差矩阵</span>
</span><span class="line">Sig <span class="o">&lt;-</span> cov<span class="p">(</span>x<span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="c1"># 计算特征值和特征向量</span>
</span><span class="line">eigen<span class="p">(</span>Sig<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>得到结果如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="o">$</span>values
</span><span class="line"><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="m">2381.3724526</span>    <span class="m">0.3681085</span>    <span class="m">0.1165201</span>
</span><span class="line">
</span><span class="line"><span class="o">$</span>vectors
</span><span class="line">           <span class="p">[,</span><span class="m">1</span><span class="p">]</span>       <span class="p">[,</span><span class="m">2</span><span class="p">]</span>        <span class="p">[,</span><span class="m">3</span><span class="p">]</span>
</span><span class="line"><span class="p">[</span><span class="m">1</span><span class="p">,]</span> <span class="m">-0.2982259</span> <span class="m">-0.4601189</span>  <span class="m">0.83627265</span>
</span><span class="line"><span class="p">[</span><span class="m">2</span><span class="p">,]</span> <span class="m">-0.6002191</span> <span class="m">-0.5908325</span> <span class="m">-0.53912331</span>
</span><span class="line"><span class="p">[</span><span class="m">3</span><span class="p">,]</span> <span class="m">-0.7421579</span>  <span class="m">0.6627273</span>  <span class="m">0.09997061</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>得到了特征值为：<script type="math/tex">\lambda_1=238.372, \lambda_2=0.368, \lambda_3=0.11652</script>，可以看到第一主成分<script type="math/tex">y_1=t_1'x=-0.298x_1-0.600x_2-0.742x_3</script>的特征值<script type="math/tex">\lambda_1</script>的值远大于其余的(由于数据构造时就是以<script type="math/tex">x_1</script>为底的)。说明第一主成分能够解释数据的大部分信息，那么如何衡量呢？</p>

<p>这时候就需要使用到<strong>贡献率</strong>这个概念，某一个主成分<script type="math/tex">y_i</script>的贡献率定义为：<script type="math/tex">\frac{\lambda_i}{\sum_{i=1}^{p} \lambda_i}</script>。</p>

<p>贡献率越大说明这个主成分能够解释数据的信息就越多，在具体的问题中，还常常用到一个概念，就是<strong>累积贡献率</strong>。前<script type="math/tex">k</script>个主成分的累计贡献率就是：<script type="math/tex">\frac{\sum_{i=1}^{k} \lambda_i}{\sum_{i=1}^{p} \lambda_i}</script>。实际中，当前<script type="math/tex">k</script>个主成分的累积贡献率达到某个临界值，比如<script type="math/tex">80\%</script>，就选择前<script type="math/tex">k</script>个主成分进行下一步操作(比如说聚类，回归或者单纯地做分析等等)</p>

<h4 id="section-3">四、基于相关矩阵</h4>
<hr />

<p>考虑这样两种情况：各个变量的单位不全相同，也就是数据的量纲不同；各变量之间的单位相同，但是变量的方差较大，也就是数值大小相差较大。那么这个时候，如果从协方差矩阵出发求解主成分，就显得不大合适了。</p>

<p>在之前的文章中提到过，当所有的变量都进行了标准化之后，协方差矩阵<script type="math/tex">\Sigma</script>就转换成了相关矩阵<script type="math/tex">R</script>！</p>

<p>那么，剩下的求解过程就与上面相同了，这里不再叙述。需要指出的是，标准化与否，所得到的结果可能会有很大的不同，所以，判断一批数据是否需要标准化是很有必要的！</p>

<h4 id="r">五、R语言实现</h4>
<hr />

<p>主成分分析的R语言实现比较简单，可以直接使用<code>eigen()</code>函数求出特征值特征向量。当然也有自带的函数：<code>princomp()</code>以及<code>psych</code>包中的<code>principal()</code>函数，可以自己查找一下帮助文档，这里就不做介绍了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[书籍推荐]]></title>
    <link href="http://jackycode.github.io/blog/2014/05/09/books-recommended/"/>
    <updated>2014-05-09T17:17:14+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/05/09/books-recommended</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical32.jpg" alt="artical 32" />
<!-- more --></p>

<p>图为我写这篇博文时，我书桌的样子！</p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>大牛一条微博，我这冷清的小屋子倒是热闹了很多，在此谢谢<a href="http://macshuo.com/">池建强</a>池老大！不过说实话，一下多出这么多人气来，我的脑袋倒是有点不够用了。本来我就写写我学习的东西，新的我就边学边记，学过的就当复习！这回这么多人来光顾，我突然有点压力了。不过也好，压力也是动力，能够促使我好好学习好好努力，不懈怠！</p>

<p>说说对于博客的一些安排吧！我本来的打算呢，就是利用写博客，将自己学过的一些东西进行查漏补缺，也是进行一遍系统的回顾！当然，写出来比自己看书复习要难得多，一开始写东西总是数学味道、学术感觉！很多文字改了又改，觉得别人能够看懂才发。当然了，有很多数学气息太浓的我就跳过没有写出来；也有很多写出来的，但我却没有能力将他转换成简单的语言！一句话，就是需要继续好好努力！</p>

<p>对学习的东西进行一次系统的回顾，我大致是分了三个方向：统计模型、数据挖掘算法、数据可视化。</p>

<ol>
  <li>统计模型的话，到现在为止应该就是介绍了线性回归和Logistic回归！以后会逐步添加一些模型，肯定是越来越复杂！</li>
  <li>算法的话，到现在为止介绍过分类算法：kNN, Decision Tree, Naive Bayes；聚类算法：KMeans；关联分析中的Apriori算法。初步打算是将一些基础的常见的算法都介绍一遍。</li>
  <li>数据可视化，这个方向的东西还没有具体写过。暂时还没有给这个专题安排具体写的内容，也还没有安排时间。</li>
</ol>

<hr />

<p>好了，唠叨完我博客的事儿，来说说正事儿吧：<strong>书籍推荐</strong></p>

<p>其实老早就像系统地理一遍我学过看过的一些书了，乘着今儿有空，就来理一理，也算是给别人一个不好不坏的教材！</p>

<p>不管学什么，看书是少不了的。前贤的经验累积，系统的学习思路，完整地学习内容，这些都不是在博客或者论坛上看两篇文章，翻三篇帖子能够做到的。</p>

<p>由于我是数学系出身(学校的统计专业是放在数学系下面的)，我自己对数学理论看得比较重，而且我也觉得应该看得重！很多统计模型，很多算法都是建立在复杂的概率统计理论上的，数学学的不好，我觉得想要学好数据科学是不太现实的！当然，如果你只想做个使用者，只需要知道如何点点点然后搞出结果来，那就另当别论！</p>

<p><strong><em>书单：</em></strong></p>

<h4 id="section">(一). 理论方面</h4>

<ol>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B005AOT9BC/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">数学分析</a>(微积分)和<a href="http://www.amazon.cn/gp/product/B004CLZJD6/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">高等代数</a>(线性代数)</p>

    <p>数分高代是数学系的基础课，括号里面应该是非数学专业在本科时候学过的。总体上来说这两者讲的内容大致相同，只是数分高代会更看重理论方面的证明，会介绍更多理论方面的知识。如果学过微积分和线性代数，看看数分高代我觉得应该还不错，而且难度应该不是很大。</p>
  </li>
  <li>
    <p>概率论与数理统计</p>

    <p>这个就不用多说了吧，不看这个学什么数据分析啊！没有给出链接的原因是：我在网上找不到我以前用的那本，那本是甘肃教育出版社出的！找不到，我就推荐一本我觉得不错的好了：<a href="http://www.amazon.cn/gp/product/B001FSJFQQ/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">概率统计</a>，这本北京大学出版社出的，是我看过觉得写的很不错的，但是可能比一般的概率论与数理统计教材难一些！</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B001Q3LM2A/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">随机过程</a></p>

    <p>这个对于统计专业的人来说肯定不陌生，学这个时候应该还是痛苦过的吧！反正我是痛苦过~我给出的是北京大学出版社，何书元教授编写的一本本科教材。难度适中，但是我觉得讲的挺好挺全的！另外还有一本<a href="http://www.amazon.cn/gp/product/B0046W8Q5O/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">随机过程导论</a>，如果有能力就看英文的，写的蛮不错的！</p>
  </li>
</ol>

<h5 id="section-1">下面进化一下，进入更深层次的理论。这边我就不想多说什么，因为下面的东西，别说非数学系的觉得难，就是数学系的也觉得非常难！但是个人觉得还是很有用很重要的！当然，这部分可以选读，甚至是直接跳过，等用到了再来纠结(但还是建议看一看，那以后纠结的时候会轻松一点)！</h5>

<ol>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B0019K922C/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">实变函数论</a>和<a href="http://www.amazon.cn/gp/product/B002AVJJEA/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">泛函分析</a></p>

    <p>两个逆天的理论，讲的理论逆天，难度也是逆天的！怎么讲，数分进化了一波就算是实变了，实变再进化一波就是泛函了~建议需要用到比较深得微分积分方程的人重点看看，实变函数是指以实数作为自变量的函数，实变函数论就是以实变函数作为研究对象的数学理论，里面涉及到微分理论、积分理论、测度理论等等。泛函指的是函数的函数，泛函分析研究的就是实数域以及复数域上的完备赋范线性空间，也就是巴拿马空间！</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B00116JNH8/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">测度论与概率论基础</a></p>

    <p>我给出的链接是本科生的教材，讲的内容是比较简单的。如果想挑战一下，或者看完了这本不过瘾的，可以试试这本<a href="http://www.amazon.cn/gp/product/B008BPWNJW/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">测度论讲义</a>和<a href="http://www.amazon.cn/gp/product/B002U57NJY/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">高等概率论</a></p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B0011CR4HS/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">参数统计教程</a></p>

    <p>看完了概率论的进化版，就该看看数理统计的进化版了，俗称高等数理统计。我给出的是韦博成教授编写的教材，内容详实，理论丰富，不过排版上总让我感觉字密密麻麻的！</p>
  </li>
  <li>
    <p>随机过程</p>

    <p>晋级版的随机过程，说实话，我真不知道哪本书好，因为我当时看的是我老板的自己写的手稿。而且我觉得那份手稿写的非常全面非常好，没有再看过其它的书！真是，不知道该怎么推荐了！据说这本不错，但我也没看过，只能就贴这了：<a href="http://www.amazon.cn/gp/product/B00186GHDY/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">随机过程论</a></p>
  </li>
</ol>

<h4 id="section-2">(二). 概率统计方面</h4>

<p>数学理论看完之后，就需要学习一下概率统计方面的知识了。这边也还有一个比较难的理论课程，那就是<strong><em>极限理论</em></strong>。不过，这个课程好像不是搞统计必备的，因为我这边的研究生同学们，统计方向的都没有学过这个。下面就罗列罗列一些有关统计方面的书籍吧：</p>

<ol>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B005NGLIQQ/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">应用回归分析</a></p>

    <p>当时我学的时候，这本书还是第2版，记得里面好像有些错漏，但是总体来讲书很不错，讲的很全很细致。给出的链接是第三版的，相信里面的一些小错漏肯定已经更正了。</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B002PF2CD6/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">应用多元分析</a></p>

    <p>好巧，当时学这本书的时候，它也是第2版，现在也更新的第三版了。这本书个人觉得不错，对学习SAS也挺有帮助的。当然王斌会教授编著的‘多元统计分析及R语言建模’，我觉得很不错，不过没能在亚马逊上找到。这本就是用R语言来讲的，不过理论方面可能较前一本就弱了！</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B0028QHKIY/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">时间序列分析</a></p>

    <p>我没有给出当时我们上课用的教材，因为我个人不喜欢那本教材，觉得讲的让我不能够很容易地接受。除了上面给出的那本，还有一本英文的很不错：‘Time Series Analysis With Applications in R’，这个有中文翻译的版本，但是强烈不推荐，因为翻译的太那什么了！</p>
  </li>
  <li>
    <p><a href="http://product.dangdang.com/22800977.html#ddclick?act=click&amp;pos=22800977_0_1_q&amp;cat=&amp;key=%B3%E9%D1%F9%BC%BC%CA%F5&amp;qinfo=40_1_48&amp;pinfo=&amp;minfo=&amp;ninfo=&amp;custid=&amp;permid=20140509150655657412097357383939675&amp;ref=http%3A%2F%2Fwww.dangdang.com%2F&amp;rcount=&amp;type=&amp;t=1399619232000">抽样技术</a></p>

    <p>版本也从2升到了3，想想当年这个课，大部分都是打瞌睡过去的！想想本科没有好好学习就惭愧啊~~这本书介绍了很多常用的抽样方法，最后给出了一个实例，书编的还行。除了这本，我其实也没看过其它相关的书籍，所以就推荐这个吧！</p>
  </li>
  <li>
    <p><a href="http://product.dangdang.com/20529065.html#ddclick?act=click&amp;pos=20529065_0_1_q&amp;cat=&amp;key=%B7%C7%B2%CE%CA%FD%CD%B3%BC%C6&amp;qinfo=31_1_48&amp;pinfo=&amp;minfo=&amp;ninfo=&amp;custid=&amp;permid=20140509150655657412097357383939675&amp;ref=http%3A%2F%2Fsearch.dangdang.com%2F%3Fkey%3D%25B3%25E9%25D1%25F9%25BC%25BC%25CA%25F5&amp;rcount=&amp;type=&amp;t=1399620077000">非参数统计</a></p>

    <p>这本书是我读研之后才开始看的，本科的时候学校没教，我就没学，真是罪过罪过！</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B0046A8EB2/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">最优化方法</a></p>

    <p>把它放在这边是因为：很多问题求解的时候会用到它！如何有时间，也应该看看<a href="http://www.amazon.cn/gp/product/B0011F2ZPQ/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">数值分析</a>，对很多统计问题的求解会有帮助。</p>
  </li>
</ol>

<p>到这边的话，基本上统计方面的基础理论就有了。当然如果你是统计专业的学生肯定不会只学这些，记得本科的时候还学过西方经济学、保险学原理、会计学原理等等等等。当然，我这边只介绍概率统计的理论书籍，</p>

<h4 id="section-3">(三). 统计软件及其它</h4>

<p>本科学校着重介绍了两种统计软件，SAS和SPSS。但是我在我大三尝试过R语言的滋味后，我把SPSS打入了冷宫！随着我大四将电脑换成Mac，SAS也成为了过去时！怎么说呢，SAS功能强大无可否认，但是对我这种喜欢各种折腾的人来说，SAS明显不够啊！R不同，我想怎么玩儿就可以怎么玩，只要我愿意，我可以让它帮我关机，我也曾经用它写过情书给我女朋友，这个SAS只怕是难以胜任的。不过这不能说孰优孰劣，只能说合适。SAS商用肯定会比R有优势，它稳定安全，功能强大，可以帮助企业做很多事情。对于企业而言，R语言就略显自由了一点。不过SAS跟R比做数据方面的研究，那就明显不如了。</p>

<p>不说那么多了，SAS这货都木有Mac版本，暂时我是不会再去用它了(浪费了我无数个日夜在那边研究SAS啊。。。)！</p>

<p><strong><em>先说SAS</em></strong></p>

<ol>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B0057DJULK/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">SAS应用统计分析</a></p>

    <p>当时本科时候用的SAS基础教程，现在来看，版本就显得老了点。这本书用SAS去处理统计分析问题，讲的全面到位。而且，这本书的后半部分介绍了很详细的SAS编程技术，当做入门再好不过了。当然，如果想学好SAS，我还是建议去官网找帮助文档，多如牛毛啊那是！你要什么专题的都有，唯一的问题就是，全是英文！</p>
  </li>
  <li>
    <p><a href="http://product.dangdang.com/20933928.html#ddclick?act=click&amp;pos=20933928_7_0_q&amp;cat=&amp;key=%CD%B3%BC%C6%C8%ED%BC%FE%D3%A6%D3%C3%BD%CC%B3%CC&amp;qinfo=41_1_48&amp;pinfo=&amp;minfo=&amp;ninfo=&amp;custid=&amp;permid=20140509150655657412097357383939675&amp;ref=http%3A%2F%2Fwww.dangdang.com%2F&amp;rcount=&amp;type=&amp;t=1399621982000">SAS9.1统计软件应用教程</a></p>

    <p>这本比之上面那本就薄很多啦，这本书对SAS编程介绍得很少，基本属于单刀直入各类统计问题。其中的问题又以医学数据为主，看看其实也蛮不错的！不过还是强烈建议上面那一本！</p>
  </li>
</ol>

<p><strong><em>说完SAS，说说R吧</em></strong></p>

<ol>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/144931208X/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">R in a Nutshell</a></p>

    <p>我想说这是我看过最全面的一本R语言书籍，包括R语言基础、R语言编程、R语言的数据操作、R语言的数据可视化方法、R语言中的统计学应用以及R语言程序优化方法、生物统计，甚至介绍了R语言和Hadoop的结合使用。在这本书的附录中，还介绍了很多R语言的程序包，这是我看过的R语言书籍中比较满意以及喜欢的一本。</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B00ASOR6QY/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">R in Action</a></p>

    <p>这是另外一本我比较喜欢的R语言书籍，这本书在介绍了最基础的R语言操作和图形知识之后，循序渐进地，紧贴统计学理论介绍R语言的编程和图形绘制！看完这本书，R语言编程、R语言绘图以及很多基础的统计模型就都得到了学习巩固！这本书的中文版，我觉得翻译地很不错，对英文无爱的可以看中文版！</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/1449357105/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">Learning R</a></p>

    <p>这本书侧重于R语言编程，书分为两个部分，前一部分介绍R语言的各个细节；后一部分介绍使用R进行数据分析的流程。这本书看完，R语言编程能力好不好，那就是看你练得多不多了，因为该教你的都已经教你了！</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/0387759352/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">Software for Data Analysis: Programming with R</a></p>

    <p>说R语言编程好像不能漏了这本书，因为这本书从理论基础上介绍了R语言的一切，除了说一句里面的英文很难懂之外，我不想做任何其它介绍，因为我觉得我不够资格！</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B00COIRE6Y/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">ggplot2:数据分析与图形艺术</a></p>

    <p>这个应该不用多说什么，这是R语言的一座大山，爬上去之后，使用R语言绘图就从普通走向了文艺，从平凡走向了高雅！！！中文版除了插图黑白之外，其它都还不错！</p>
  </li>
</ol>

<h4 id="section-4">(四). 其它一些我看过以及看着的书</h4>

<ol>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/1617290181/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">Machine Learning in Action</a></p>

    <p>作者使用最简单语言，易懂的流程一步一步介绍了机器学习中的很多方法。书中使用Python作为实现的编程语言，也让我见识到为什么那么多人喜欢Python！后来，我的世界里面多了一个Python！</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/B009O65XPS/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">鲜活的数据：数据可视化指南</a></p>

    <p>这是一本在读的书，作者在书中使用各种各样的方式实现数据可视化，当你看到作者绘制出来的图时，我相信你会跟我一样，买下这本书去学习！</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/Pro-Data-Visualization-Using-R-and-JavaScript-Barker-Tom/dp/1430258063/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1399624364&amp;sr=1-1&amp;keywords=Pro+Data+Visualization+Using+R+and+JavaScript">Pro Data Visualization Using R and JavaScript</a></p>

    <p>这本书才看了其中介绍空间数据可视化的一章，觉得还是蛮不错的！</p>
  </li>
  <li>
    <p><a href="http://www.amazon.cn/gp/product/1107422221/ref=olp_product_details?ie=UTF8&amp;me=&amp;seller=">Machine Learning: The Art and Science of Algorithms That Make Sense of Data</a></p>

    <p>Machine Learning的理论内容应有尽有，讲解详尽，我表示很喜欢！</p>
  </li>
  <li>
    <p>书很多，一本一本往下看也看不完，关键是：你看了之后学了多少！</p>
  </li>
</ol>

<p>介绍到这我也有点累了，最后，我想说，看书是必要的，但是学习的时候别忘了还有Google这个好工具。很多时候，一本书上不会将一个问题讲得特别深入透彻，那你就需要去查找一些资料，找一些别人做的研究出来看看！另外，学习R语言的时候，别忘了R语言那强大的帮助系统，而且很多Package都是带有PDF格式的介绍文档，也有很多自带演示！记住三个函数：<code>?</code>,<code>demo()</code>,<code>vignette()</code>。</p>

<p>除了上述所说的，网上其实也有很多优秀的网站，比如<a href="http://cos.name/">统计之都</a>,<a href="http://scikit-learn.org/stable/">scikit-learn</a>,<a href="http://www.r-bloggers.com/">R-bloggers</a>,<a href="http://flowingdata.com/">FlowingData</a>,<a href="http://www.datatau.com/?utm_campaign=Manong_Weekly_Issue_14&amp;utm_medium=EDM&amp;utm_source=Manong_Weekly">DataTau</a>,<a href="http://www.statmethods.net/">Quik-R</a>等等，当然，别忘了R语言的<a href="http://www.r-project.org/">官网</a>,上面的材料非常的多！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习14: 关联分析之apriori算法]]></title>
    <link href="http://jackycode.github.io/blog/2014/05/07/apriori/"/>
    <updated>2014-05-07T17:00:48+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/05/07/apriori</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical31.jpg" alt="artical 31" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>在上一篇中，我们介绍了关联分析相关的概念，这一节来看看如何使用Apriori算法去寻找满足条件的项集。</p>

<p>首先回顾一个概念，<strong>一个项集的支持度</strong>就是数据集中该项集所占的比例。Apriori算法就是用于寻找数据集中，支持度和可信度超过某一给定值的项集和关联规则。</p>

<hr />

<h4 id="section">一、原理</h4>
<hr />

<p>在介绍算法之前，首先了解一个集合论中的性质定理：集合的向下封闭性。</p>

<p>我们通过一个例子来看看这个定理，见下图：</p>

<p><img src="http://jackycode.github.io/images/a31/apriori_1.jpg" alt="" /></p>

<p>集合的向下封闭性，在这边解释的话，也就是说，<strong>如果一个项集的支持度低于某一个值，那么该项集超集的支持度也必定低于这个值。如果一个项集的支持度高于某一个值，那么该项集子集的支持度也必定高于某一个值。</strong></p>

<p><strong>超集</strong>：就是指包含这个集合中所以元素的集合（不包括自身），比如集合ABC就是集合AB的超集。</p>

<p>那么这个定理放在上一个图当中，就有这样的含义：</p>

<p><img src="http://jackycode.github.io/images/a31/apriori_2.jpg" alt="" /></p>

<hr />

<h4 id="section-1">二、算法构成</h4>
<hr />

<p>有了上面这个原理，那么就可以利用这个原理去减少我们寻找频繁集的计算量。因为，只要我们找到一个项集，其支持度低于给定的值，那么这个项集的所有超集就可以直接忽略不计了。如上图，项集A的支持度低于指定的值，那么其超集就都不用再考虑了。</p>

<p><strong>Apriori算法由两部分构成：</strong></p>

<ol>
  <li>找到满足最小支持度的项集；</li>
  <li>找到可信度超过最小可信度的关联规则。</li>
</ol>

<p>下面，我们一个一个地解决：</p>

<hr />

<h5 id="section-2">2.1. 寻找频繁项集</h5>
<hr />

<p>利用上面所讲的原理，我们来整理一下这个步骤的流程：</p>

<ol>
  <li>从数据集中构造集合C1，C1满足：大小为1的所有候选项集的集合，例如上图中的：C1 = {A, B, C};</li>
  <li>计算C1中所有项集（单元素项集）是否满足最小支持度，满足的项集构成集合L1，例如上图中的：L1 = {B, C};</li>
  <li>利用L1生成新的候选项集C2，C2满足：大小为2的所有候选项集的集合，例如上图中得：C2 = {BC};</li>
  <li>计算C2中所有项集（双元素项集）是否满足最小支持度，满足的项集构成集合L2；</li>
  <li>重复直到Lk中得元素个数为1。</li>
</ol>

<hr />

<h5 id="section-3">2.2. 寻找关联规则</h5>
<hr />

<p>在得到频繁项集之后，要寻找关联规则就容易多了。可以直接从频繁项集中构造初始的关联规则，计算该关联规则的可信度，然后与给定的最小可信度作比较，若值大于最小可信度，则记录该关联规则。</p>

<p>在实际编程时，需要注意使用<strong>集合的向下封闭性</strong>！！！想想看，在关联规则中，这个性质应该怎样去实现？(可以到Machine Learning in Action中找答案！)</p>

<h4 id="r">三、R语言实现</h4>

<h5 id="section-4">1. 使用自带的程序</h5>

<p>在R语言的<code>arules</code>这个包里面，提供了一个实现Apriori算法的函数：<code>apriori()</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1"># 构造数据集</span>
</span><span class="line">dataSet <span class="o">&lt;-</span> matrix<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
</span><span class="line">rownames<span class="p">(</span>dataSet<span class="p">)</span> <span class="o">&lt;-</span> paste<span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">,</span> sep<span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">)</span>
</span><span class="line">colnames<span class="p">(</span>dataSet<span class="p">)</span> <span class="o">&lt;-</span> c<span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">)</span>
</span><span class="line">dataSet<span class="p">[</span><span class="m">1</span><span class="p">,]</span> <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
</span><span class="line">dataSet<span class="p">[</span><span class="m">2</span><span class="p">,]</span> <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
</span><span class="line">dataSet<span class="p">[</span><span class="m">3</span><span class="p">,]</span> <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
</span><span class="line">dataSet<span class="p">[</span><span class="m">4</span><span class="p">,]</span> <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
</span><span class="line">dataSet<span class="p">[</span><span class="m">5</span><span class="p">,]</span> <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
</span><span class="line">dataSet
</span><span class="line"><span class="c1"># 转换数据格式(可以?apriori查看数据格式)</span>
</span><span class="line">dataSet_class <span class="o">&lt;-</span> as<span class="p">(</span>dataSet<span class="p">,</span><span class="s">&quot;transactions&quot;</span><span class="p">)</span>
</span><span class="line"><span class="c1"># 构造频繁项集</span>
</span><span class="line">rules<span class="o">&lt;-</span>apriori<span class="p">(</span>dataSet_class<span class="p">,</span>parameter<span class="o">=</span>list<span class="p">(</span>supp<span class="o">=</span><span class="m">0.5</span><span class="p">,</span>conf<span class="o">=</span><span class="m">0.6</span><span class="p">,</span>target<span class="o">=</span><span class="s">&quot;rules&quot;</span><span class="p">))</span>
</span><span class="line"><span class="c1"># 查看结果</span>
</span><span class="line">summary<span class="p">(</span>rules<span class="p">)</span>
</span><span class="line"><span class="c1"># 构造关联规则</span>
</span><span class="line">inspect<span class="p">(</span>rules<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="section-5">2. 自定义函数解决</h5>

<p>相对而言，Apriori算法的函数比较难以编写，原因可想而知，肯定是因为数据结构的问题！但是也只是比其他函数难编一点，毕竟其自带的数据结构功能还是非常强大的。我在<a href="http://jackycode.github.io/datascience">我的项目</a>中给出的一种编写方式，是利用R语言的list来实现的。不过，我想，利用Matrix或者data.frame，当然如果你还懂<code>data.table</code>的话，那么肯定也是可以编写的，而且我想应该会比用list简单！(没有亲手编写，只是猜想！)</p>

<p>详见<a href="http://jackycode.github.io/datascience">我的项目</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R语言记录8：Loop Functions]]></title>
    <link href="http://jackycode.github.io/blog/2014/05/04/loop-functions/"/>
    <updated>2014-05-04T14:56:40+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/05/04/loop-functions</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical30.jpg" alt="aritical 30" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>循环对于编程的重要性不言而喻，但是大量的使用<code>for</code>语句、<code>while</code>语句在R语言这种交互式命令行上，其实并不和谐。而且，很多时候，我们希望使用更短更少的代码去完成一个事情。这就需要用到R语言中自带的一些函数，使用这些函数可以把循环变得容易表述。不过，这当然是有学习成本的，要想掌握得多尝试多思考。</p>

<p>在RSeries系列中，我之前也介绍过<code>tapply</code>这样的Loop function，但是并没有很全面地去说这个问题。没有介绍这块内容呢，总觉得对于R语言编程来说缺少了点什么，今天就来详细地说说R语言中的Loop Functions。</p>

<p>在R语言中，处理循环的函数常用的大致有这么几个：<code>lapply</code>, <code>sapply</code>, <code>apply</code>, <code>tapply</code>, <code>mapply</code>。每一个函数都有其自身的特性与用途，下面我们来一个一个地说。</p>

<hr />

<h4 id="lapply">1. <code>lapply</code>函数</h4>
<hr />

<p><code>lapply</code>函数：<strong>对list的每一个元素(list[[i]])执行指定的函数操作，其返回值总是一个列表</strong>。举个简单地例子，比如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">x <span class="o">&lt;-</span> list<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="o">:</span><span class="m">5</span><span class="p">,</span> <span class="m">10</span><span class="o">:</span><span class="m">14</span><span class="p">)</span>
</span><span class="line">lapply<span class="p">(</span>x<span class="p">,</span> mean<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [[1]]</span>
</span><span class="line"><span class="c1">## [1] 2.5</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[2]]</span>
</span><span class="line"><span class="c1">## [1] 3.5</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[3]]</span>
</span><span class="line"><span class="c1">## [1] 12</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>也就是对列表x的每一个元素<code>x[[i]]</code>执行指定的函数操作，这边就是求均值<code>mean</code>。</p>

<p>当然，<code>lapply</code>函数不仅仅可以对列表做出处理，也可以是向量，不过这个情况并不适用于任何地方。比如，你想生成随机数，第一次生成1个，第二次生成3个，第三次5个，那么可以试试这个函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">lapply<span class="p">(</span>c<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">),</span> rnorm<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [[1]]</span>
</span><span class="line"><span class="c1">## [1] -0.5622</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[2]]</span>
</span><span class="line"><span class="c1">## [1] -0.8519  0.3671  0.4243</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[3]]</span>
</span><span class="line"><span class="c1">## [1]  0.09395 -1.19474  1.52337 -1.97529  0.47370</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样使用的情况非常少，使用时需要特别注意一下。</p>

<p>当然，在<code>lapply</code>中你也可以使用自定义的函数，比如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">x <span class="o">&lt;-</span> list<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="o">:</span><span class="m">5</span><span class="p">,</span> <span class="m">10</span><span class="o">:</span><span class="m">14</span><span class="p">)</span>
</span><span class="line">lapply<span class="p">(</span>x<span class="p">,</span> <span class="kr">function</span><span class="p">(</span>item<span class="p">)</span> any<span class="p">(</span>item <span class="o">==</span> <span class="m">5</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [[1]]</span>
</span><span class="line"><span class="c1">## [1] FALSE</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[2]]</span>
</span><span class="line"><span class="c1">## [1] TRUE</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[3]]</span>
</span><span class="line"><span class="c1">## [1] FALSE</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这边，自定义函数中使用<code>item</code>代表<code>x</code>的每一个元素，你也可以使用任何你想用的字符表示。</p>

<hr />

<h4 id="sapply">2. <code>sapply</code>函数</h4>
<hr />

<p><code>sapply</code>函数与<code>lapply</code>函数使用与处理上完全相同，唯一不同的是，<code>sapply</code>会尽可能地简化输出地结果。如果可能，<code>sapply</code>会输出向量或者矩阵；当然，如果实在不行，它就会输出列表，这个时候就与<code>lapply</code>函数一模一样了。接着上面一个例子看看：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">x <span class="o">&lt;-</span> list<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="o">:</span><span class="m">5</span><span class="p">,</span> <span class="m">10</span><span class="o">:</span><span class="m">14</span><span class="p">)</span>
</span><span class="line">sapply<span class="p">(</span>x<span class="p">,</span> <span class="kr">function</span><span class="p">(</span>item<span class="p">)</span> any<span class="p">(</span>item <span class="o">==</span> <span class="m">5</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [1] FALSE  TRUE FALSE</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<hr />

<h4 id="apply">3. <code>apply</code>函数</h4>
<hr />

<p><code>apply</code>函数：对数组或矩阵，按行或者按列进行指定的函数操作。看个简单地例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">x <span class="o">&lt;-</span> matrix<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">12</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
</span><span class="line">x
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">##      [,1] [,2] [,3]</span>
</span><span class="line"><span class="c1">## [1,]    1    5    9</span>
</span><span class="line"><span class="c1">## [2,]    2    6   10</span>
</span><span class="line"><span class="c1">## [3,]    3    7   11</span>
</span><span class="line"><span class="c1">## [4,]    4    8   12</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">apply<span class="p">(</span>x<span class="p">,</span> <span class="m">1</span><span class="p">,</span> mean<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [1] 5 6 7 8</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">apply<span class="p">(</span>x<span class="p">,</span> <span class="m">2</span><span class="p">,</span> mean<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [1]  2.5  6.5 10.5</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其中，<code>apply(data, margin, fun)</code>，<code>margin=1</code>即是按行求；<code>margin=2</code>即是按列求。</p>

<hr />

<h4 id="tapply">4. <code>tapply</code>函数</h4>
<hr />

<p><code>tapply</code>函数：对向量的一个子集执行指定的函数。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">str<span class="p">(</span>tapply<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## function (X, INDEX, FUN = NULL, ..., simplify = TRUE)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其中<code>x</code>是需要处理的向量，<code>INDEX</code>是因子(因子列表)，<code>FUN</code>是需要执行的函数，<code>simplify</code>指是否简化输入结果(考虑sapply对于lapply的简化)。</p>

<p>看个简单地例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">x <span class="o">&lt;-</span> <span class="m">1</span><span class="o">:</span><span class="m">12</span>
</span><span class="line">x
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">##  [1]  1  2  3  4  5  6  7  8  9 10 11 12</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">Index <span class="o">&lt;-</span> gl<span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
</span><span class="line">Index
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">##  [1] 1 1 1 1 2 2 2 2 3 3 3 3</span>
</span><span class="line"><span class="c1">## Levels: 1 2 3</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">Index2 <span class="o">&lt;-</span> gl<span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
</span><span class="line">Index2
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">##  [1] 1 1 1 2 2 2 3 3 3 4 4 4</span>
</span><span class="line"><span class="c1">## Levels: 1 2 3 4</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">tapply<span class="p">(</span>x<span class="p">,</span> Index<span class="p">,</span> sum<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">##  1  2  3 </span>
</span><span class="line"><span class="c1">## 10 26 42</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">tapply<span class="p">(</span>x<span class="p">,</span> Index2<span class="p">,</span> sum<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">##  1  2  3  4 </span>
</span><span class="line"><span class="c1">##  6 15 24 33</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>不简化输出结果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">tapply<span class="p">(</span>x<span class="p">,</span> Index2<span class="p">,</span> sum<span class="p">,</span> simplify <span class="o">=</span> <span class="kc">FALSE</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## $`1`</span>
</span><span class="line"><span class="c1">## [1] 6</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## $`2`</span>
</span><span class="line"><span class="c1">## [1] 15</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## $`3`</span>
</span><span class="line"><span class="c1">## [1] 24</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## $`4`</span>
</span><span class="line"><span class="c1">## [1] 33</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="mapply">5. <code>mapply</code>函数</h4>
<hr />

<p><code>mapply</code>函数：对一个函数，使用指定的参数集合进行运算。看个简单地例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">mapply<span class="p">(</span>mean<span class="p">,</span> <span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="o">:</span><span class="m">8</span><span class="p">,</span> <span class="m">3</span><span class="o">:</span><span class="m">6</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [1] 1 2 3 4</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面这个指令进行了什么运算呢？就是计算了集合(1,5,3),(2,6,4),(3,7,5),(4,8,6)四个集合各自的平均值。</p>

<h5 id="section">如何处理其他参数</h5>

<p>很多时候，函数并非只有一个输入参数，有一些其它的参数怎么处理呢？</p>

<p>使用<code>rnorm</code>函数来举个例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">set.seed<span class="p">(</span><span class="m">10</span><span class="p">)</span>
</span><span class="line">mapply<span class="p">(</span>rnorm<span class="p">,</span> <span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span> mean <span class="o">=</span> <span class="m">2</span><span class="p">,</span> sd <span class="o">=</span> <span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [[1]]</span>
</span><span class="line"><span class="c1">## [1] 2.019</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[2]]</span>
</span><span class="line"><span class="c1">## [1]  1.6315 -0.7427</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[3]]</span>
</span><span class="line"><span class="c1">## [1] 0.2025 2.8836 3.1694</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">set.seed<span class="p">(</span><span class="m">10</span><span class="p">)</span>
</span><span class="line">mapply<span class="p">(</span>rnorm<span class="p">,</span> <span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span> mean <span class="o">=</span> <span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span> sd <span class="o">=</span> <span class="m">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [[1]]</span>
</span><span class="line"><span class="c1">## [1] 1.019</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[2]]</span>
</span><span class="line"><span class="c1">## [1] 1.8157 0.6287</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[3]]</span>
</span><span class="line"><span class="c1">## [1] 2.401 3.295 3.390</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上述的命令应该与下面的命令效果相同：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">set.seed<span class="p">(</span><span class="m">10</span><span class="p">)</span>
</span><span class="line">list<span class="p">(</span>rnorm<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> rnorm<span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">),</span> rnorm<span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [[1]]</span>
</span><span class="line"><span class="c1">## [1] 2.019</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[2]]</span>
</span><span class="line"><span class="c1">## [1]  1.6315 -0.7427</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[3]]</span>
</span><span class="line"><span class="c1">## [1] 0.2025 2.8836 3.1694</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">set.seed<span class="p">(</span><span class="m">10</span><span class="p">)</span>
</span><span class="line">list<span class="p">(</span>rnorm<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> rnorm<span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> rnorm<span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="c1">## [[1]]</span>
</span><span class="line"><span class="c1">## [1] 1.019</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[2]]</span>
</span><span class="line"><span class="c1">## [1] 1.8157 0.6287</span>
</span><span class="line"><span class="c1">## </span>
</span><span class="line"><span class="c1">## [[3]]</span>
</span><span class="line"><span class="c1">## [1] 2.401 3.295 3.390</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-1">小节</h4>
<hr />

<p>Loop Functions可以在很大程度上简化我们所写的代码，能够帮我们简化很多操作，比如重复地输入一些东西等等！学好它可能对于程序运行本身没有多大的帮助，但是代码并不只是写给计算机看的，也是写给人看的！我认为，好的代码应该是简洁舒适的，阅读起来让自己和别人都觉得是一种美的享受！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习13: 关联分析]]></title>
    <link href="http://jackycode.github.io/blog/2014/05/04/associationg-ananlysis/"/>
    <updated>2014-05-04T10:12:50+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/05/04/associationg-ananlysis</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical29.jpg" alt="artical 29" />
<!-- more --></p>

<p>标题图片出处：<a href="http://www.hypertextbookshop.com/dataminingbook/public_version/contents/chapters/chapter002/section003/blue/page002.html">Rule Generation</a></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h4 id="section">一、简介</h4>
<hr />

<p>在统计学中，变量与变量之间的关系是统计结构的重要参数，统计的核心问题也就是研究变量与变量之间的关系。如果变量与变量之间不独立，那么这两个变量之间肯定存在一定的关联性，那么如何处理度量这个关联性，在统计中就称为关联分析。</p>

<p>列联表是传统统计学中度量两个分类变量之间关系强弱的方法，但是这个方法是对于两个固定的变量进行的一种测量。在机器学习中，常常会遇到大规模的变量，这时候更倾向于从众多的变量中最快地找到关联性最强的两组或多组变量。那么使用列联表就显得不太合适了，此时应该使用什么方法呢？</p>

<hr />

<h4 id="section-1">二、关联规则</h4>
<hr />

<p>首先介绍2个定义：</p>

<ol>
  <li><strong>k项集：</strong>设<script type="math/tex">I = \{ i_1, i_2, \dots, i_m \}</script>是$m$个待研究的项构成的有限项集，对于给定的事物数据表<script type="math/tex">T = \{ T_1, T_2, \dots, T_n \}</script>，其中任意的$T_i$是$I$中的$k$项组成的集合，称之为<strong>k项集</strong>。</li>
  <li><strong>关联规则</strong>：形如<script type="math/tex"> X \rightarrow Y</script>的形式，其中<script type="math/tex"> X \subseteq I </script>, <script type="math/tex">Y \subseteq I</script>，且有<script type="math/tex"> X \bigcap Y = \emptyset </script>。</li>
</ol>

<hr />

<h5 id="section-2">度量方式</h5>
<hr />

<p>对于一个项集，我们正常用支持度来度量它的频繁程度，其实就是其在数据集中出现的比例，这个很容易理解，就不多说了。</p>

<p>那么下面要讨论的就是：<strong>如何度量一个关联规则</strong>。一般使用下面两个概念：</p>

<ol>
  <li><strong>支持度S</strong>：定义为X和Y同时出现在一个事务中得可能性，即：
 <script type="math/tex"> S(X \Rightarrow Y) = \mid T(X \vee Y) \mid / \mid T \mid </script>
 其中，<script type="math/tex">\mid T(X \vee Y) \mid</script>表示同时包含X和Y的事务数，<script type="math/tex">\mid T \mid</script>表示总事务数。</li>
  <li><strong>支持度C</strong>：定义为出现在关联规则前项中得事务中出现关联规则后项的比例，即：
 <script type="math/tex"> C(X \Rightarrow Y) = \mid T(X \vee Y) \mid / \mid T(X) \mid </script>
 其中，<script type="math/tex"> \mid T(X) \mid</script>表示包含X的事务数。</li>
</ol>

<hr />

<h5 id="section-3">例子</h5>

<hr />

<p>这边举个简单地例子，方便理解上面的概念。比如设计一个购物数据：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">id</th>
      <th style="text-align: center">items</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">AB</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">AC</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">C</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">ABC</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">BC</td>
    </tr>
  </tbody>
</table>

<p>上面数据的意思，比如第一行就表示，id为1的人购买了A和B两个物品，其他的意思类似。那么这个AB就是一个2项集，因为存在ABC三种物品，这边就有6种关联规则：<script type="math/tex">A \Rightarrow B</script>, <script type="math/tex">A \Rightarrow C</script>, <script type="math/tex"> B \Rightarrow C</script>, <script type="math/tex"> B \Rightarrow A </script>, <script type="math/tex"> C \Rightarrow A</script>, <script type="math/tex"> C \Rightarrow B </script>。</p>

<p>那么如何计算一个关联规则的支持度与可信度呢？</p>

<p>试试关联规则<script type="math/tex">A \Rightarrow B</script>：</p>

<script type="math/tex; mode=display"> S(A \Rightarrow B) =  \mid T(A \vee B) \mid / \mid T \mid = 2/5 </script>

<script type="math/tex; mode=display"> C(A \Rightarrow B) =  \mid T(A \vee B) \mid / \mid T(A) \mid = 2/3 </script>

<p>是不是很简单呢。试试计算一下其他的关联规则，多算几次就能够很了解其中的含义了。</p>

<hr />

<h5 id="section-4">关联规则的作用</h5>
<hr />

<ol>
  <li>
    <p>关联规则的目的在于，找到变量之间支持度和可信度都比较高的那些关联规则。</p>
  </li>
  <li>
    <p>关联规则的支持度，用于度量关联规则在数据库中得普适程度，是对关联规则重要性(适用性)的一种度量。</p>
  </li>
  <li>
    <p>关联规则的可信度，这是一个相对指标，是对关联规则准确度的一个度量。值越高，代表这个关联规则的后项依赖前项的可能性比较高。</p>
  </li>
</ol>

<hr />

<h4 id="section-5">小节</h4>
<hr />

<p>这篇简单介绍了一下关联分析的一些概念问题，以及如何度量一个关联规则。但是，试想一想，要是$I$中包含的项很多，事物数据表$T$也很大，那么要计算所有关联规则的支持度和可信度，难度可想而知！这时候就需要使用一些算法去解决这个问题，现在比较流行的算法就是：处理静态关联规则的Apriori算法和处理动态关联规则的Carma算法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac 系统重装]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/30/reinstall-mac/"/>
    <updated>2014-04-30T20:57:58+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/30/reinstall-mac</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical28.jpg" alt="artical 28" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>话说Mac一般来讲不需要什么重装啊，不过世事无绝对啊，有时候人就是喜欢作死！！！比如前几天的我~~~算了，具体情况就不说了，反正就是作死，Mac系统出了问题。本来想着用Time Machine恢复一下就得了，也省事。不过仔细想了一想，很想自己安装一遍（博主的折腾精神有时候很是让自己“佩服”），然后就开始了Mac系统重装之旅！</p>

<h3 id="usb">一、制作USB安装盘</h3>
<hr />

<p>要安装首先就得制作一个启动U盘，当然你也可以使用Mac的Internet Recovery，不过我试了一下，反正我是连不上！不过即使连上了，那个下载应该也需要超久的时间，不是我可以等得了的。我之前更新Mac时，已经下载好了Mavericks（OS X 10.9），所以直接拿来用了。</p>

<h4 id="section">具体操作如下：</h4>

<ol>
  <li>将OS X 10.9安装文件放到桌面上，右键选择“显示包内容”；</li>
  <li>复制”Contents/Resources/createinstallmedia”到桌面；</li>
  <li>打开终端，执行命令：<code>sudo -s</code>，切换到root（成功的话，应该会显示<code>bash-3.2#</code>）；</li>
  <li>将U盘（8G以上）接入Mac，用磁盘工具进行格式化，格式选择<strong>“Mac OS扩展（日志式）”</strong>，名称定为<strong>“OSX”</strong>；</li>
  <li>
    <p>在终端中执行下面的命令：（将其中的“username”换成你自己的用户名）</p>

    <p><code>
 /Users/username/Desktop/createinstallmedia --volume /Volumes/OSX --
</code></p>

    <p><code>
 applicationpath /Users/username/Desktop/"Install OS X Mavericks.app"
</code></p>
  </li>
  <li>等待终端完成。因为需要将安装的文件全部拷贝到U盘中，需要的时间可能有些久，不用着急，喝杯咖啡看看网页！完成后的终端会显示“Copy complete.Done.”</li>
</ol>

<p>根据上面的流程，制作的安装盘是完整的，也就是安装完成之后，Mac是有Recovery HD的（就是开机按住option可以看到得“恢复10.9”），也可以使用FileVault和find my Mac功能。网上一些直接利用磁盘工具制作的安装盘，应该是不具备这个能力的，所以不建议使用那些方法。</p>

<h3 id="section-1">二、加密与备份</h3>
<hr />

<h4 id="section-2">安装之前：</h4>

<p>在重装Mac系统之前，需要对Mac里面的文件进行一个备份。也建议使用Dropbox这样的网盘，将自己的一部分文件同步在网盘上，这样就不会存在丢失的情况。备份好之后，就可以开始重新安装Mac系统了。</p>

<h4 id="section-3">安装之后：</h4>

<ol>
  <li>在安装好了Mac系统之后，我首先进行了一些基本的设置：触控板、输入源、iCloud账号设置等等；</li>
  <li>在完成这些基础设置之后，你可以选择打开FileVault加密，增强电脑的安全系数（不过打开后，开机速度可能会变慢一些）；</li>
  <li>强烈建议打开Time Machine，给电脑做个备份；</li>
</ol>

<h3 id="command-line-tools">三、安装Command Line Tools</h3>
<hr />

<p>为什么需要将这个独立出来？哎，没办法啊。。。在Mac上很多事情都靠他，离了它，估计我就没法好好生活好好学习好好过日子了！！！（夸张夸张！）</p>

<p>这个的安装，我是直接下载了XCode和Command Line Tools之后安装的。用App Store下载Xcode，那个速度我实在是等不了。</p>

<h3 id="java">四、安装Java</h3>
<hr />

<p>由于平时需要使用Weka，当然还有那个什么，那个什么~~~反正很多啦，都是需要Java支持的，像Matlab！嘿嘿。。。所以去安装一个Java吧，虽然我很不喜欢它！</p>

<h3 id="shell">五、配置shell</h3>
<hr />

<p>Mac默认使用的时bash，表示不喜欢。在对电脑进行各种软件安装配置之前，必须把Terminal搞成我喜欢的样子，嘿嘿~~</p>

<ol>
  <li>切换shell到<code>zsh</code>：<code>chsh -s /bin/zsh</code>；</li>
  <li>
    <p>首先安装<code>Homebrew</code>，执行下面的命令即可：</p>

    <p><code>
 ruby &lt;(curl -fsSkL raw.github.com/mxcl/homebrew/go)
</code></p>
  </li>
  <li>安装<code>wget</code>：<code>brew install wget</code></li>
  <li>安装<code>oh-my-zsh</code>：<code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></li>
  <li>修改配置文件<code>.zshrc</code>；</li>
  <li>修改主题文件，主题文件的目录为<code>~/.oh-my-zsh/themes</code>，找到自己使用的主题，进行修改即可。</li>
</ol>

<h3 id="r">六、R语言相关</h3>
<hr />

<p>每天都在使用R语言，离了这个可真是活不了！下载好了R 和 RStudio之后，直接安装就好了。不过，这边可能会出现一个问题，就是在Mac上可能会出现encoding之类的问题，这个时候就需要设置一下，打开终端运行以下的命令即可：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">defaults write org.R-project.R force.LANG en_US.UTF-8</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>安装好之后，将自己常用的包下载一下就OK了！</p>

<h3 id="python">七、Python</h3>
<hr />

<p>除了R语言，应该算是这货用的最多，所以安装好了R之后，就开始来弄它了。</p>

<p>Mac是自带Python的，10.9自带的版本是Python 2.7.5，我一般使用的是Python 2.7.6，所以首先需要更新一个Python。以前我使用的软件包管理系统是Macports，不过现在已经叛逃到了Homebrew了！</p>

<ol>
  <li>
    <p>执行<code>brew install python</code>就可以下载安装最新版的Python了。不过安装好了之后，还是用不了的。因为Mac还是会用自带的那个Python。这个我一般就是将Homebrew的软件包目录加入PATH中，并且将该软件包目录的位置放置于其它目录的上方。</p>

    <p>可以使用<code>sudo vi etc/paths</code>打开系统的PATH，然后在里面的第一行添加Homebrew的软件包安装目录<code>\usr\local\bin</code>，第二行添加为<code>\usr\local\sbin</code>，其实只要再<code>\usr\bin</code>的上方就行了。</p>
  </li>
  <li>安装好这些之后，可以使用Python自带的<code>easy_install</code>安装<code>pip</code>，即：<code>easy_install pip</code>；</li>
  <li>使用<code>pip</code>安装需要的python库：<code>pip install numpy</code>等等。我一般安装的是库有：<code>numpy, scipy, matplotlib, ipython, scikit-learn</code>等。</li>
</ol>

<h3 id="sublime-text--textmate">八、Sublime Text &amp; TextMate</h3>
<hr />

<p>我一般使用的文本编辑器就是上面两个，ST3常用，TM用的稍微少一些。配置的时候，ST3稍微麻烦一些，TM则简单地多，只要点点点就可以了。</p>

<h4 id="sublime-text-3">Sublime Text 3</h4>

<ol>
  <li>
    <p>安装好ST之后先安装Package Control，打开view -&gt; show console，在console中输入代码。可以到<a href="https://sublime.wbond.net/installation">这里</a>去查看安装的最新代码(区分ST2以及ST3)；</p>
  </li>
  <li>
    <p>配置安装主题Flatland（我的最爱），使用<code>shift + cmd + P</code>打开Package Control，输入<code>install package</code>，return之后等待一下。在弹出的窗口中输入<code>Flatland</code>，安装即可。安装完成后，打开Prefereces -&gt; Settings - User，添加配置：</p>

    <p><code>
 "color_scheme": "Packages/Theme - Flatland/Flatland Monokai.tmTheme",
 "theme": "Flatland Dark.sublime-theme"
</code></p>

    <p>当然还可以对这个主题进行其它配置，可以自行Google；</p>
  </li>
  <li>
    <p>修改字体，还是在Setting-User中，添加：</p>

    <p><code>
 "font_face": "menlo",
 "font_size": 13
</code></p>
  </li>
  <li>安装一些常用的包：<code>ConvertToUTF8</code>, <code>Enhanced-R</code>, <code>SublimeLinter</code>, <code>SublimeREPL</code>, <code>OmniMarkupPreviewer</code>, <code>Markdown Extended</code>, <code>Jedi - Python autocompeltion</code>, <code>Alignment</code>, <code>BracketHighlighter</code>, <code>SendText</code>, <code>SideBarEnhancements</code>, <code>TrailingSpaces</code>等等。</li>
  <li>对有些需要配置的包配置一下，其实我也就配置了跟R语言有关的包，以及R语言在ST的快捷键。</li>
</ol>

<h4 id="textmate">TextMate</h4>

<p>这个配置起来比较容易，只需要在Preferences -&gt; Bundles下面选择需要安装的包就可以了。我安装了一些我常用的包，然后将主题更换成了<code>Made of Code</code>，将<code>show command output</code>修改成了<code>Right of text view</code>。</p>

<h3 id="section-4">九、安装其它的软件</h3>
<hr />

<p>完成上面的安装，基本上就能用了，但是我需要在R中使用Knitr和Sweave，所以我得安装MacTex，顺便还装了Lyx。</p>

<p>安装好了MacTex之后，我就安装了其它一些平时会用的软件，像Octave、Weka、MySQL等等！</p>

<p>剩下的就是常用软件了，什么Dropbox、Evernote、iWork等等！！！iWork那个下载速度很是蛋疼啊~~~</p>

<h3 id="section-5">总结</h3>
<hr />

<p>因为是隔了好几天才动笔写这个记录的，所以应该记录之中不免会有些遗漏！当然，中间或多或少肯定也存在一些问题，欢迎指正！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习12: Logisic回归]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/27/logistic-regression/"/>
    <updated>2014-04-27T10:34:11+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/27/logistic-regression</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical27.jpg" alt="artical 27" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>在数据科学系列的开头，花了三篇介绍了线性回归。线性回归模型应该是定量分析中最常用的一种统计分析方法。但是线性回归处理数据时，要求因变量是连续型变量。但是很多时候，需要处理的数据，其因变量并不是连续的。像性别、对错等等，这种离散的因变量，一般称为分类响应变量。</p>

<p>在机器学习的<a href="http://jackycode.github.io/blog/2014/03/30/data-science-an-introduction-to-machine-learning/">介绍篇</a>中，已经介绍了监督学习与非监督学习。在监督学习中，最主要的两类问题，一个就是回归，另一个就是分类。而Logistic回归就是处理二元分类的一种方法，当然其也存在自身的问题，这个后面再讲。</p>

<h4 id="sigmoid">Sigmoid函数</h4>
<hr />

<p>要了解Logistic回归，首先需要了解一下Sigmoid函数。为什么呢？</p>

<p>一般来说，我们会定义二元分类变量的输出为0和1，这种函数叫做单位阶跃函数，也称Heaviside step function。这个函数的特点就是其取值可以从0突变到1，反之也可。学过数分的话就知道，这种函数有时候会非常难以处理，因为带跳突变，导致了不可微不可导。在这里，就可以借助Sigmoid函数，因为这个函数可以近似地描述单位阶跃函数的特点。首先看看Sigmoid函数：</p>

<script type="math/tex; mode=display"> p = \frac{exp(y)}{1+exp(y)} = \frac{1}{1 + exp(-y)}</script>

<p>简单看一下这个函数，当$y=0$时，$p=0.5$；当$y$变大，趋近于无穷时，$y$趋近1；反之，$y$趋近0。而且，这种趋近的速度是非常快的。正是因为这个趋近速度非常快，我们可以使用Sigmoid函数来处理这边的单位阶跃函数。</p>

<h4 id="logistic">Logistic回归</h4>
<hr />

<h5 id="section">模型建立</h5>

<p>利用Sigmoid函数可以将单位阶跃函数做个近似，而Sigmoid函数是连续的，那么就可以利用之前的线性回归来建立模型。</p>

<p>令$ y = X\beta $，又<script type="math/tex"> p = \frac{1}{1 + exp(-y)} </script>，变形可得Logistic回归模型：</p>

<script type="math/tex; mode=display"> logit(p) = ln(\frac{p}{1-p}) = X\beta </script>

<p>上述的$logit(p)$称为$logit$变换，此时$p$就是响应变量，$X$就是自变量。到这，模型就建立好了，剩下就是如何对参数进行估计了。</p>

<h5 id="section-1">参数估计</h5>

<p>参数估计可以从两个方面来考虑，一个从最优化的方式，一个从统计角度！</p>

<p><strong>最优化的方式</strong>，是将模型转换成：<script type="math/tex"> p = sigmod(X\beta) </script>来考虑，对于估计值<script type="math/tex">\hat{\beta}</script>，应该使得其预测值<script type="math/tex">\hat{p}</script>与实际值<script type="math/tex">p</script>之间的差达到最小！即：</p>

<script type="math/tex; mode=display"> \hat{\beta} = \min_{\beta} \mid p - sigmod(X\beta) \mid</script>

<p>有了这个，我们就可以使用最速下降法等等最优化的方法去求解参数的估计值了。</p>

<p><strong>统计角度</strong>，那就需要考虑模型中<script type="math/tex">p</script>的统计意义了，这个属于广义线性模型的范畴，现在不想多说，有兴趣的话可以翻翻资料！也可以根据下面说的<strong>统计中的解释</strong>去试试，看看如何使用极大似然估计去估计参数。</p>

<h5 id="section-2">统计中的解释</h5>
<hr />

<p>这里面的$p$除了利用Sigmoid函数来解释之外，还可以利用统计中的二项分布来解释，而且从某种角度来说，这个解释会更便于理解。试想，我们这边需要处理的二元分类变量就是0和1。我们考虑0就是“不发生”，1就是“发生”，那么我们可以将前面的$p$理解成发生的概率。通过对已知数据建立模型，估计出参数，我们就可以利用模型去预测在不同的自变量条件下，“发生”的概率是多大，从而达到一个分类的目的。</p>

<p>从这边的分析就可以看到，Logistic回归的缺点：那就是欠拟合，会导致分类的精度下降。</p>

<h5 id="r">R语言实现</h5>
<hr />

<p>因为Logistic回归是属于广义线性回归模型的，在R中有专门处理广义线性模型的函数<code>glm</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">model &lt;- glm(formula, family=binominal(link = "logit"), data=data.frame)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里处理的方式中，利用了连接函数(link=logit)，感兴趣的话可以找找广义线性模型的内容看看，当然，以后如果介绍统计模型的话，这个肯定也是必讲得内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习11: 聚类分析2]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/24/cluster-analysis2/"/>
    <updated>2014-04-24T09:39:02+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/24/cluster-analysis2</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical26.jpg" alt="artical 26" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>上一篇介绍了聚类分析的定义，给出了很多不同的相似性的度量方法。这一篇主要想介绍一下除了快速聚类之外的另外一种聚类方法：<strong>系统聚类法</strong>。</p>

<h3 id="section">二、系统聚类法</h3>
<hr />

<p>系统聚类法，hierarchical clustering method，是聚类分析方法中用的较多的一种。其具体过程如下：</p>

<ol>
  <li>对于n个样品，构造n个类，每个样品单独作为一类。计算每个类之间的距离；</li>
  <li>合并距离最近的两个类为一个新类；</li>
  <li>计算新类与其它类之间的距离，重复2直到所有类合并称为1个类为止。</li>
</ol>

<p>那么类与类之间的距离如何定义呢？</p>

<p>其实，类与类之间的距离有很多中定义方式常见的有：</p>

<ol>
  <li>最短距离法，single linkage method，<script type="math/tex"> D_{KL} = \min_{i \in G_K,j \in G_L} d_{ij} </script>；</li>
  <li>最长距离法，complete linkage method，<script type="math/tex"> D_{KL} = \max_{i \in G_K,j \in G_L} d_{ij} </script>；</li>
  <li>中间距离法，median linkage method，即取最远距离与最近距离两者的中间距离；</li>
  <li>类平均法，average linkage method，<script type="math/tex"> D_{KL} = \frac{1}{n_Kn_L} \sum_{i \in G_K,j \in G_L} d_{ij} </script>；</li>
  <li>重心法，centroid hierarchical method，即取类重心之间的距离；</li>
  <li>离差平方和法，Ward’s minimum variance method, 定义较为繁琐，可以自行Google；</li>
</ol>

<p><strong>注</strong>：系统聚类的方法并不困难，但是实现时会存在计算量的问题。系统聚类法一般是在样品间距离矩阵的基础上进行的，它需要计算所有点到所有点之间的距离，当样品量很大时，这个计算量会变得非常的大。因而，很多时候人们会采用动态聚类的方法去处理数据，动态聚类法中一种最常用的方法就是之前已经介绍过的KMeans方法。</p>

<h4 id="r">R语言实现</h4>

<p>在R语言中，自带了一个函数可以实现系统聚类：<code>hclust</code>。可以自己查阅help。</p>

<h3 id="section-1">三、聚类的一些问题</h3>
<hr />

<ol>
  <li>量纲问题。实际问题中，由于数据采用的量纲不同，很多时候需要对数据进行一些变换，最常用的就是标准化。但也有一些其它方式：极差变换（数据除以极差）；主成分变换（用主成分代替本身数据）；对数变换等等。</li>
  <li>kmeans算法只有在类的平均值可以被定义的情况下使用，所以在一些特殊的场合，kmeans并不适用。比如分类数据等等!!</li>
  <li>kmeans算法使用平均值作为衡量，这就造成了一个新的问题。即kmeans不适用于含有异常值的数据，非凸面的数据以及大小值相差很大的数据。</li>
  <li>聚类的一个<strong>难点</strong>在于：确定类的个数。通过上面介绍的算法来看，所有的方法都需要自己去定义类的个数。那么如何去定义类的个数呢？这是一个到现在还没有满意解决的问题。常用的方式就是观察样品散点图，查看变化率，以及使用一些假设检验的方式（感兴趣可以翻阅专业的书籍材料，比如上海财经出版社的应用多元分析中就有讲到这部分内容）。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习10: 聚类分析1]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/21/cluster-analysis/"/>
    <updated>2014-04-21T18:46:04+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/21/cluster-analysis</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical25.jpg" alt="artical 25" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>上一篇介绍了聚类分析中的KMeans算法，这一节就来具体地说说聚类分析。聚类分析，cluster analysis，是一种研究“物以类聚”现代统计学分析方法，其目的是要把分类对象按照一定的规则分成若干个类。这些类别并非事先给定的，而是根据数据的特征确定的。</p>

<hr />

<h5 id="note">NOTE：聚类的划分：</h5>

<ol>
  <li>
    <p>根据分类对象的不同，可以分为：<strong>Q型聚类分析</strong>和<strong>R型聚类分析</strong>。Q型是指对样品对象进行聚类；而R型则是对变量(属性)进行聚类。</p>
  </li>
  <li>
    <p>按照分析方法的不同，又可以分为：<strong>系统聚类法</strong>、<strong>快速聚类法</strong>和<strong>模糊聚类法</strong>。上一篇介绍的KMeans法就是快速聚类法中的一种。</p>
  </li>
</ol>

<hr />

<h4 id="section">一、相似性的度量</h4>
<hr />

<p>在上一篇中，我们已经介绍过，聚类其实就是将相似度高的样品啊属性啊合并成一个类别。但是，上一篇我们仅仅给出了一种也是最简单的一种相似性的度量方式——欧式距离。这里我们详细看看相似性有哪些度量方式：</p>

<p>除了使用<strong>有序尺度变量</strong>（将属性划分为一级、二级等等的有次序关系的量来表示）和<strong>名义尺度变量</strong>（使用既没有等级关系，又不存在数量关系的量来表示。比如男女）之外，一般采用的测量尺度的方式就是<strong>间隔尺度变量</strong>。</p>

<p><strong>间隔尺度变量</strong>即是使用连续的量来表示测量尺度，一般都是连续型的，比如欧式距离、重量等等。一般来讲，在应对Q型聚类时会使用<strong>距离</strong>去度量；而对R型聚类来说，则会使用<strong>相似系数</strong>这种方式去度量。下面来分别看一看：</p>

<hr />

<h5 id="a-">a. 距离</h5>
<hr />

<p>上一篇中使用的欧氏距离即是这里的一种，在介绍各种不同的距离定义之前，首先看看距离的定义需要满足哪些条件：</p>

<ol>
  <li>首先，距离必须是非负的。即：<script type="math/tex">d_{ij} \geqslant 0, \forall i,j</script>;</li>
  <li>对于相同取值的样品，之间的距离必须为0。即：<script type="math/tex">d_{ij} = 0</script>，当且仅当，第i个样品与第j个样品的各变量值相同；</li>
  <li>i样品到j样品的距离与j样品到i样品的距离相等。即：<script type="math/tex">d_{ij} = d_{ji}, \forall i, j</script>；</li>
  <li>满足：<script type="math/tex">d_{ij} \leqslant d_{ik} + d_{kj}, \forall i,j,k</script>。</li>
</ol>

<p>下面就来看看常用的距离定义，首先看看最常用的Minkowski距离：</p>

<hr />

<h6 id="minkowski">(1). Minkowski距离</h6>

<script type="math/tex; mode=display"> d_{ij}(q) = [\sum_{k=1}^{p} {\mid x_{ik} - x_{jk} \mid ^ q}]^{1/q} </script>

<p>观察这个距离可以看到，当$q=2$时，上面定义的距离就是常用的欧氏距离。另外：</p>

<ul>
  <li><script type="math/tex">q=1</script>时，<script type="math/tex">d_{ij}=\sum_{k=1}^{p} {\mid x_{ik} - x_{jk} \mid}</script>称为<strong>绝对值距离</strong>；</li>
  <li><script type="math/tex">q=\infty</script>时，<script type="math/tex">d_{ij}=\max_{1 \leqslant k \leqslant p} {\mid x_{ik} - x_{jk} \mid}</script>称为<strong>切比雪夫距离</strong>。</li>
</ul>

<p>Minkowski距离存在一个问题，就是当变量的单位不同或者测量值范围相差很大时，直接使用Minkowski距离效果不佳。这个时候，应该先对数据进行<strong>标准化</strong>（就是减去均值除上标准差）之后再计算距离(这个后面还会说到)。</p>

<hr />

<h6 id="lancelance-and-williams">(2). Lance距离(Lance and Williams)</h6>

<p>当$x_{ji} &gt; 0$时，定义第i个样品到第j个样品的距离为：</p>

<script type="math/tex; mode=display"> d_{ij} = \sum_{k=1}^{p} {\frac{\mid x_{ik} - x_{jk} \mid}{x_{ik} + x_{jk}}} </script>

<p>从公式就可以看出来，这个距离与变量之间的单位没有什么关系；而且其对异常值也不敏感，因而适用于一些高度偏斜的数据。</p>

<hr />

<h6 id="mahalanobis">(3). Mahalanobis距离(马氏距离)</h6>

<p>上面的两种距离都没有考虑变量之间的相关性问题，马氏距离就可以考虑到这个问题。但是由于马氏距离定义的问题，在聚类分析中使用马氏距离并不合适。但是这里也还是给出马氏距离的定义：</p>

<script type="math/tex; mode=display"> d_{ij} = \sqrt{(x_i - x_j)^TS^{-1}(x_i - x_j)} </script>

<p>其中<script type="math/tex">x_i = (x_{i1}, \dots, x_{ip})^T</script>，<script type="math/tex">x_j = (x_{j1}, \dots, x_{jp})^T</script>，<script type="math/tex">S</script>为样本协方差阵。</p>

<p><strong><em>注：</em></strong>为什么说马氏距离不适用与聚类分析呢？</p>

<p>聚类分析是无监督算法中的一种，无监督算法是什么？无监督算法是没有先验信息的，所有的数据拿过来是没有什么目标信息啊什么的。没有不同类之间的先验信息，那么协方差阵<script type="math/tex">S</script>就无法计算。因而，在实际聚类分析中，马氏距离并不适用。</p>

<hr />

<h6 id="section-1">(4). 斜交空间距离</h6>

<script type="math/tex; mode=display"> d_{ij} = [ \frac{1}{p^2} \sum_{k=1}^{p} \sum_{l=1}^{p} (x_{ik} -x_{jk})(x_{il} - x_{jl})r_{kl} ] ^ {1/2} </script>

<p>其中<script type="math/tex">r_{kl}</script>是变量<script type="math/tex">x_k</script>与变量<script type="math/tex">x_l</script>的相关系数。学过高等代数的应该可以很容易看明白这个定义。此外，当变量之间互不相关的时候，这里的<script type="math/tex">d_{ij} = [d_{ij}(2)/p]_{Minkowski}</script>，也就是退化到了欧氏距离（相差一个常数倍）。</p>

<hr />

<h5 id="b-">b. 相似系数</h5>
<hr />

<p>对变量进行聚类时，通常使用相似系数来考量其间的相似度。那么相似系数的定义有需要满足哪些条件呢？</p>

<ol>
  <li>完全相关。即：$c_{ij} = \pm 1$，当且仅当$x_i = ax_j + b;a(\neq 0),b$是常数；</li>
  <li><script type="math/tex">\mid c_{ij} \mid \leqslant 1, \forall i, j </script>；</li>
  <li><script type="math/tex">c_{ij} = c_{ji}, \forall i, j </script>。</li>
</ol>

<p>下面看看常用的两种相似系数：</p>

<hr />

<h6 id="section-2">(1). 夹角余弦</h6>
<hr />

<p>变量$x_i$和$x_j$的夹角余弦的定义为：</p>

<script type="math/tex; mode=display"> c_{ij} = \frac{\sum_{k=1}^{n} {x_{ki}x_{kj}} }{ [ (\sum_{k=1}^{n}{ x^2_{ki} })(\sum_{k=1}^{n} {x^2_{kj}} ) ]^{1/2} } </script>

<p>学过解析几何应该很容易看出这个定义的含义所在，其实<script type="math/tex">c_{ij} = \cos \theta_{ij}</script>。</p>

<hr />

<h6 id="section-3">(2). 相关系数</h6>
<hr />

<script type="math/tex; mode=display"> c_{ij} = \frac { \sum _{ k=1 }^{ n }{ ({ x }_{ ki }-\overline{x_i})({ x }_{ kj }-\overline{x_j}) }  }{ \{ [\sum_{k=1}^{n}({ x }_{ ki }-\overline{x_i})^2][\sum_{k=1}^{n}({ x }_{ kj }-\overline{x_j})^2] \}^{1/2} } </script>

<p>这里的相关系数其实就是统计里面通常所说的相关系数。其实，如果变量都是标准化了的，那么夹角余弦就是相关系数，看出来了吗？</p>

<hr />

<h4 id="section-4">小节</h4>
<hr />

<p>到这边，就把统计中常用的用于度量相似性的定义讲了一些。这些定义，大都有其自身的数学背景。有些来自于几何学，有些来自于线性空间理论。对于使用者来说，搞明白什么时候选择什么样的度量方式更加重要！下一篇，我们讲一讲聚类分析中的一个常用方法：<strong>系统聚类法</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习9: 聚类算法之KMeans]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/19/kmeans/"/>
    <updated>2014-04-19T13:01:02+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/19/kmeans</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical24.jpg" alt="artical 24" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h2 id="the-k-means-algorithm">The k-means algorithm</h2>
<hr />

<p>前面写了很多监督学习的东西，除了回归就是分类，今儿有点想换换口味，写写无监督学习的算法。k-means算法是一种聚类算法，聚类就是无监督学习里面的内容。那么先来说说聚类：</p>

<h3 id="section">一、聚类简介</h3>
<hr />

<ol>
  <li>
    <p>聚类是一种无监督学习方法，它主要就是将相似的对象归并到一个类别中。</p>
  </li>
  <li>
    <p>聚类分析的目的是把分类对象按照一定的规则，分成若干个类。这些类并不是事先给定的，而是在处理数据时，根据数据的特征确定的。因而，在处理之前无需对类的数目、结构等等作出假定(理论如此，实际应用时并不完全这样，以后讲聚类分析时再具体说)。</p>
  </li>
  <li>
    <p>在同一类别中，对象具有某种意义下的相似性；不同的类别中，对象具有某种意义下的不相似。</p>
  </li>
  <li>
    <p><strong>聚类与分类的最大不同</strong>：分类的目标事先已知，而聚类未知。正因为聚类产生的结构与分类相同，只是类别没有预先定义，所以聚类也被称为“无监督分类”。</p>
  </li>
</ol>

<h3 id="k-means">二、k-means法</h3>
<hr />

<p>k-means法是由MacQueen提出并命名的一种聚类算法。其使用聚类中的均值进行聚类划分，这样说不大好理解，可以先看一下算法的基本步骤：</p>

<ol>
  <li>从n个数据对象中任意取出k个样品对象作为初始聚类点（或者将所有数据分成k份，计算每一份中的重心（均值）作为初始聚类点）；</li>
  <li>对所有样品对象逐个归类，将每一个对象归入距离他最近的那个类（距离一般使用欧式距离），并将该类的凝聚点更新为这个类当前的均值；</li>
  <li>重复步骤2，直至所有对象都不能再分配为止。</li>
</ol>

<h3 id="r">三、R语言实现</h3>
<hr />

<h4 id="section-1">1. 自定义函数</h4>
<hr />

<p>自定义一个函数<code>se_kmeans</code>，使用这个函数可以通过输入需要聚类的数据集以及类别数目k，即可得到每一个样品的类别以及各个类别的中心。该函数使用欧式距离作为相似性的度量（当然还有很多其它方式，之后的聚类分析中会讲到），具体的程序可以在<a href="http://jackycode.github.io/datascience">我的项目</a>中找到，也可以直接到我的<a href="https://github.com/JackyCode/Data_Science">github</a>中查看源代码。这边给出测试代码以及结果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">x1 <span class="o">&lt;-</span> matrix<span class="p">(</span>rnorm<span class="p">(</span><span class="m">500</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0.5</span><span class="p">),</span> <span class="m">100</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span><span class="line">x2 <span class="o">&lt;-</span> matrix<span class="p">(</span>rnorm<span class="p">(</span><span class="m">500</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">0.5</span><span class="p">),</span> <span class="m">100</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span><span class="line">x <span class="o">&lt;-</span> rbind<span class="p">(</span>x1<span class="p">,</span> x2<span class="p">)</span>
</span><span class="line">
</span><span class="line">clusters <span class="o">&lt;-</span> se_kmeans<span class="p">(</span>x<span class="p">,</span> <span class="m">2</span><span class="p">)</span>
</span><span class="line">clusters
</span><span class="line">plot<span class="p">(</span>x<span class="p">,</span> col<span class="o">=</span>clusters<span class="o">$</span>cluster<span class="p">,</span> pch<span class="o">=</span>as.character<span class="p">(</span>clusters<span class="o">$</span>cluster<span class="p">),</span> cex<span class="o">=</span><span class="m">0.5</span><span class="p">)</span>
</span><span class="line">points<span class="p">(</span>clusters<span class="o">$</span>center<span class="p">,</span> col<span class="o">=</span><span class="s">&#39;green&#39;</span><span class="p">,</span> pch<span class="o">=</span><span class="s">&#39;o&#39;</span><span class="p">,</span> cex <span class="o">=</span> <span class="m">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>得到如下的一张图</p>

<p><img src="\images\a24\kmeans1.jpg" alt="kmeans1" /></p>

<p>可以看到，分类效果是很好的。</p>

<h4 id="kmeans">2. 使用<code>kmeans</code>函数</h4>
<hr />

<p>可以使用<code>stats</code>包中的<code>kmeans</code>函数来实现，示例如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">x1 <span class="o">&lt;-</span> matrix<span class="p">(</span>rnorm<span class="p">(</span><span class="m">500</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0.5</span><span class="p">),</span> <span class="m">100</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span><span class="line">x2 <span class="o">&lt;-</span> matrix<span class="p">(</span>rnorm<span class="p">(</span><span class="m">500</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">0.5</span><span class="p">),</span> <span class="m">100</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span><span class="line">x <span class="o">&lt;-</span> rbind<span class="p">(</span>x1<span class="p">,</span> x2<span class="p">)</span>
</span><span class="line">
</span><span class="line">clusters <span class="o">&lt;-</span> kmeans<span class="p">(</span>x<span class="p">,</span> <span class="m">2</span><span class="p">)</span>
</span><span class="line">clusters
</span><span class="line">plot<span class="p">(</span>x<span class="p">,</span> col<span class="o">=</span>clusters<span class="o">$</span>cluster<span class="p">,</span> pch<span class="o">=</span>as.character<span class="p">(</span>clusters<span class="o">$</span>cluster<span class="p">),</span> cex<span class="o">=</span><span class="m">0.5</span><span class="p">)</span>
</span><span class="line">points<span class="p">(</span>clusters<span class="o">$</span>centers<span class="p">,</span> col<span class="o">=</span><span class="s">&#39;green&#39;</span><span class="p">,</span> pch<span class="o">=</span><span class="s">&#39;o&#39;</span><span class="p">,</span> cex <span class="o">=</span> <span class="m">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>得到这样一张图</p>

<p><img src="\images\a24\kmeans2.jpg" alt="kmeans2" /></p>

<p>从图中可以看出，kmeans的分类效果还是蛮不错的，当然我们可以计算一下误判，不过这显然是很小的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习8: 决策树之ID3]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/14/id3/"/>
    <updated>2014-04-14T16:02:45+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/14/id3</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical23.jpg" alt="artical 23" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>ID3算法的核心问题就在于：如何选取在决策树的每个节点处要测试的属性。那么如何去选择呢？当然，我们要选取<strong>分类能力最好的属性</strong>，那么怎么去确定哪个属性是分类能力最好的呢？ID3算法中，使用<strong>信息增益</strong>作为评判标准。在看信息增益之前，我们先看看这个决策树的构造过程：</p>

<h3 id="section">一、构造过程</h3>
<hr />

<ol>
  <li>选取<strong>分类能力最好的属性</strong>作为决策树根部节点的测试；</li>
  <li>为根节点属性的每一个可能值产生一个分支；</li>
  <li>以各个分支节点为根节点，重复上述过程。</li>
</ol>

<h3 id="section-1">二、信息增益</h3>
<hr />

<h4 id="section-2">1. 熵</h4>
<hr />

<p>在看信息增益之前，首先需要介绍一个概念，那就是<strong>香农熵</strong>，简称为<strong>熵</strong>。相信学过物理的应该大都听过这个名词，在热力学中不就有个熵增原理嘛。其实，<strong>熵是信息论中广泛使用的一个度量标准，刻画了任意样例集合的纯度。</strong></p>

<p><strong>熵是信息的期望值</strong>，所以可以用熵来刻画一个数据集的纯度。若用$x_i,i=1,2,\dots,n$来表示数据集所包含的属性，那么这个数据集的熵为：</p>

<script type="math/tex; mode=display"> H = - \sum_{i=1}^{n}{p(x_i)l(x_i)} </script>

<p>其中，$p(x_i)$表示选取$x_i$作为分类的最终类别的概率；$l(x_i)$为$x_i$的信息，定义为：<script type="math/tex"> l(x_i) = - \log_2p(x_i)</script>。</p>

<h4 id="section-3">2. 信息增益</h4>
<hr />

<p>有了熵之后就可以刻画一个数据集的纯度，也就是熵值。那么什么信息增益呢？</p>

<p>简单来说，<strong>一个属性的信息增益就是：使用这个属性分割样例集合而导致的熵值降低</strong>。那么要选取分类能力最好的属性，就是要选取使得信息增益最大的那个属性。</p>

<p>一个属性A对样例集合S的信息增益定义为：</p>

<script type="math/tex; mode=display"> Gain(S, A) = H(S) - \sum_{v \in A} { \frac{\# S_v}{\# S} H(S_v) } </script>

<p>其中，<script type="math/tex">S_v</script>表示集合S中，属性A取值为$v$的那部分数据；<script type="math/tex">\# S_v</script>表示，集合S中，属性A取值为$v$的个数；<script type="math/tex">\# S</script>表示集合S中观测的个数。</p>

<h4 id="section-4">3. 简单的例子</h4>
<hr />

<table>
  <thead>
    <tr>
      <th style="text-align: center">序号</th>
      <th style="text-align: center">age</th>
      <th style="text-align: center">income</th>
      <th style="text-align: center">buy_iphone</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">senior</td>
      <td style="text-align: center">high</td>
      <td style="text-align: center">yes</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">senior</td>
      <td style="text-align: center">low</td>
      <td style="text-align: center">no</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">youth</td>
      <td style="text-align: center">high</td>
      <td style="text-align: center">yes</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">youth</td>
      <td style="text-align: center">low</td>
      <td style="text-align: center">no</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">senior</td>
      <td style="text-align: center">high</td>
      <td style="text-align: center">yes</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">youth</td>
      <td style="text-align: center">high</td>
      <td style="text-align: center">yes</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">senior</td>
      <td style="text-align: center">high</td>
      <td style="text-align: center">no</td>
    </tr>
  </tbody>
</table>

<p>考虑上面这个问题，我们来计算一下各个属性的信息增益。</p>

<p>首先，我们可以看到，这个数据集S最终分类buy_iphone有两种取值：$yes,no$。则数据集S的熵值为：</p>

<script type="math/tex; mode=display"> H(S) = -\frac{4}{7} \log_2{\frac{4}{7} } - \frac{3}{7} \log_2{\frac{3}{7} }  \approx 0.985</script>

<p>若按照age分类，age有两个属性：$senior, youth$，分别有4个和3个。age = senior时，yes有2个，no有2个则有：</p>

<script type="math/tex; mode=display"> H_{age}(S_{senior}) = -\frac{2}{4} \log_2{\frac{2}{4}} - \frac{2}{4} \log_2{\frac{2}{4}} \approx 1 </script>

<script type="math/tex; mode=display"> H_{age}(S_{youth}) = -\frac{2}{3} \log_2 {\frac{2}{3}} - \frac{1}{3} \log_2 {\frac{1}{3}} \approx 0.918 </script>

<p>则有：</p>

<script type="math/tex; mode=display"> H_{age}(S) = \frac{4}{7} \times 1 + \frac{3}{7} \times 0.918 = 0.965 </script>

<p>则age属性的信息增益为：</p>

<script type="math/tex; mode=display"> H(S) - H_{age}(S) = 0.985 - 0.965 = 0.020 </script>

<p>那么属性income的信息增益怎么去计算，可以动手试试。</p>

<h3 id="id3">三、ID3算法的伪代码</h3>
<hr />

<h5 id="section-5">定义：</h5>
<ul>
  <li>data：为训练样本集</li>
  <li>label：为目标属性 （比如例子中的属性buy_iphone）</li>
  <li>attrs：出目标属性外，供算法学习测试使用的其它属性 （比如例子中的age和income属性）</li>
</ul>

<h5 id="section-6">伪代码：</h5>
<p>ID3(data, label, attrs)：</p>

<ol>
  <li>创建决策树的Root节点；</li>
  <li>若lable中取值单一，则返回 <code>label=label</code> 的单节点树；</li>
  <li>若attrs为空，则返回 <code>label=（data中取值最多的那个label）</code> 的单节点树；</li>
  <li>否则：
    <ol>
      <li>选取attrs中分类能力最好的属性作为Root的决策属性，记为A；</li>
      <li>对A的每一个可能取值vi：
        <ol>
          <li>在Root添加一个分支对应 <code>A = vi </code>；</li>
          <li>data_vi = data中 <code>A = vi</code> 的子集，label_vi 表示 data_vi 所对应的目标属性取值；</li>
          <li>若 data_vi 为空集：
            <ol>
              <li>在新分支下加一个叶子节点，节点 <code>label =（data中取值最多的那个label）</code> ;</li>
              <li>否则，加一个子树：ID3(data_vi, label_vi, attrs);</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>结束</li>
  <li>返回Root</li>
</ol>

<h3 id="r">四、R语言实现</h3>
<hr />

<p>见<a href="http://jackycode.github.io/datascience">我的项目</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打折的Apps]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/11/apps-at-a-discount/"/>
    <updated>2014-04-11T19:32:31+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/11/apps-at-a-discount</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical22.jpg" alt="artical 22" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<p>这两天，很多Mac和iPhone上的Apps都在打折，比如出名的Day one、1Password等等。</p>

<p>在StackSoical上面也介绍了一些，链接如下：<a href="https://stacksocial.com/ios_bundle?utm_source=ssnetwork&amp;utm_medium=hellobar&amp;utm_campaign=iosbundle">链接</a></p>

<p><img src="http://jackycode.github.io/images/a22/stack.jpg" alt="stack" /></p>

<p>StackSoical上没有介绍的，就是打折的<a href="https://agilebits.com/store">1Password</a></p>

<p><img src="http://jackycode.github.io/images/a22/1pass.jpg" alt="1pass" /></p>

<p>这些打折的应用，都可以直接在App Store购买。我暂时不知道打折持续的时间有多少，也不知道打折的原因。没关系啦，这个打折总归是我们这些消费者福音，像1Password这样贵的应用，如果需要的，抓紧时间购买吧！！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习7: 决策树]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/11/decision-trees/"/>
    <updated>2014-04-11T19:00:32+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/11/decision-trees</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical21.jpg" alt="artical 21" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h3 id="section">一、开始</h3>
<hr />

<p>在介绍决策树的概念内容之前，先来初步了解一下决策树的流程。这是一个很简单的概念，通过一张简单的流程图就可以大致了解决策树是干什么的，怎么干的。</p>

<p><img src="\images\a21\decisiontrees.jpg" alt="decision trees" /></p>

<h3 id="section-1">二、相关概念</h3>
<hr />

<h4 id="section-2">1. 一些概念</h4>
<hr />

<ul>
  <li>决策树学习是一种逼近离散值目标函数的方法。</li>
  <li>决策树通过把实例从根节点排列到某个叶子节点来分类实例，叶子的节点即为实例所属的分类。</li>
  <li>决策树上的每一个节点，指定了对实例的某一个属性的测试，并且，该节点的每一个后续分支对应该属性的一个可能值。</li>
</ul>

<h4 id="section-3">2. 分类方法</h4>
<hr />
<p>从树的根节点开始，测试这个节点指定的属性，然后按照给定实例的该属性值对应的分支向下移动。然后以新节点作为根节点重复上面的过程直至结束。</p>

<h3 id="section-4">三、 评价</h3>
<hr />

<p>通过决策树的流程，可以发现决策树的计算复杂度不高，而且其输出的结果易于理解，并且对缺失值不敏感。</p>

<p>但是，正是由于其划分过于细致，可能会导致过度匹配问题(与回归中的overfitting类似)。</p>

<h3 id="section-5">四、主要的决策树算法</h3>
<hr />

<p>从决策树的流程可以看出，<strong>如何选择属性作为节点以测试实例</strong>是最为关键的一步。不同的算法采取了不同的方法，主要的决策树算法有这样几个：</p>

<ul>
  <li>ID3</li>
  <li>C4.5 （数据挖掘十大算法之一，也是ID3算法的改进）</li>
  <li>C5.0 （C4.5的改进，适用于处理大数据集，采用Boosting方式提高模型准确率，因而又称BoostingTrees。）</li>
  <li>CART（数据挖掘十大算法之一）</li>
</ul>

<p>下一篇就开始讲讲一些决策树的算法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习6: 分类之朴素贝叶斯]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/08/naive-bayes/"/>
    <updated>2014-04-08T15:54:37+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/08/naive-bayes</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical20.jpg" alt="artical 20" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h3 id="knn">0、kNN算法的优缺点</h3>
<p>与kNN算法一样，朴素贝叶斯算法也是数据挖掘十大算法之一。我们介绍kNN算法时，并没有讨论kNN算法的优缺点，这边首先看看这个问题。</p>

<p>从构造kNN算法的过程可以看到，这个分类算法的<strong>精度很高</strong>。因为这个算法计算了所有点与待分类点之间的相似度，然后去确定带分类点的类别。由此可见，这个算法对<strong>异常值并不敏感</strong>。但是正是因为它需要计算所有点之间的距离，所以其<strong>复杂度是很高的</strong>，换句话就是，如果数据量大的话，这个算法会很费时，并不高效。</p>

<h3 id="section">一、贝叶斯决策</h3>
<hr />

<p>贝叶斯定理给出了条件概率之间的关系，是一个非常重要的定理。这里直接给出贝叶斯定理的结论：</p>

<script type="math/tex; mode=display"> P(B  \mid A) = \frac{P(A \mid B)P(B) }{P(A)} </script>

<p>在贝叶斯决策理论里面，要判断点$x$是否属于$C_i$类，只要验证是否存在：</p>

<script type="math/tex; mode=display"> p(C_i \mid x) = \max_{j} \{ P(C_j \mid x) \} </script>

<p>即是，使得$p(C_i \mid x)$达到最大的那个$C_i$就是$x$所属的类别。</p>

<h3 id="section-1">二、具体流程</h3>
<hr />

<p>要计算<script type="math/tex">P(C_i \mid x)</script>，那么就需要计算<script type="math/tex">\frac{P(x \mid C_i)P(C_i )}{P(x)}</script>，我们知道对于每一个<script type="math/tex">P(C_i \mid x)</script>，其计算公式中的分母都是<script type="math/tex">P(x)</script>，所以有：</p>

<script type="math/tex; mode=display"> P(C_i \mid x) \propto P(x \mid C_i)P(C_i ) </script>

<p>所以我们实际计算时，只需要考虑上式右侧的大小即可。首先我们来确定一些符号的意思：</p>

<ul>
  <li><script type="math/tex">x = [x_1, x_2, \dots, x_p]</script>为一个带分类的项，$x_i$为其特征；</li>
  <li>data表示一个已知分类的数据集($n \times p$的矩阵)，其每一行代表一个观测，每一列代表一个特征；</li>
  <li>label表示data中每一个数据对应的类别标签($ n \times 1$的矩阵)，比如data的第一行观测的类别就是label中的第一个取值；</li>
  <li><script type="math/tex">C = [ C_1, C_2, \dots, C_m ]</script>为一个类别集合，一般来说$ m &lt; p $。</li>
</ul>

<h5 id="section-2">步骤：</h5>

<ol>
  <li>
    <p>在已知分类的数据集data中统计：</p>

<script type="math/tex; mode=display">P(C_i), i = 1, 2, \dots, m</script>

<script type="math/tex; mode=display">P(x_j \mid C_i), i = 1, 2, \dots, m; j = 1, 2, \dots p</script>
  </li>
  <li>
    <p>计算</p>

<script type="math/tex; mode=display">P(x \mid C_i)P(C_i ) = P(C_i) \prod_{j=1}^{p} {P(x_j \mid C_i)}, i = 1, 2, \dots, m</script>
  </li>
  <li>
    <p>若</p>

<script type="math/tex; mode=display">P(x \mid C_k)P(C_k) = \max\{ P(x \mid C_i)P(C_i ) \}</script>

    <p>则<script type="math/tex"> x \in C_k</script>。</p>
  </li>
</ol>

<h3 id="section-3">三、一些存在的问题</h3>
<hr />

<ol>
  <li>当步骤的第2步中，<script type="math/tex">P(x \mid C_i)P(C_i ) = P(C_i) \prod_{j=1}^{p} {P(x_j \mid C_i)}, i = 1, 2, \dots, m</script>，中<script type="math/tex">P(x_j \mid C_i)</script>可能在样本较小时取值出现0，那么就会影响乘积；</li>
  <li>计算机计算时会出现精度问题，比如，如果<script type="math/tex">P(x_j \mid C_i)</script>的值有很多都是非常小的（像0.000001），那么计算机在计算是会将其四舍五入成0。</li>
</ol>

<p>出现上面的情况应该怎么办呢？</p>

<p>学数学的应该都清楚，遇到这种问题有一个很简单的处理方式，那就是取个对数。虽说取对数后会改变值的大小，但是取对数不会改变原本数据趋势，即原来大的数，取对数后还是大的。</p>

<p>此外，对于<script type="math/tex">P(x_j \mid C_i)</script>可能在样本较小时取值出现0的情况，处理也很简单，那就是将每一个$x_j$的初值都设置成1，所有特征的基数都从1开始，不会影响结果。（这时需要注意，所有特征的初值都是1，对应的总数初值也会发生变化。）</p>

<h3 id="r">四、R语言实现</h3>
<hr />

<p>见<a href="http://jackycode.github.io/datascience">我的项目</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据科学之机器学习5：分类之k-近邻算法]]></title>
    <link href="http://jackycode.github.io/blog/2014/04/05/knn/"/>
    <updated>2014-04-05T19:59:29+08:00</updated>
    <id>http://jackycode.github.io/blog/2014/04/05/knn</id>
    <content type="html"><![CDATA[<p><img src="http://jackycode.github.io/images/artical/artical19.jpg" alt="artical 19" />
<!-- more --></p>

<p><em>“文章原创，转载请注明出处”</em></p>

<hr />

<h4 id="section">基本思想</h4>
<hr />

<p>kNN，k-Nearest Neighbor algorithm，也就这边的k-近邻算法，是数据挖掘十大算法之一，是一个比较简单的分类方法。</p>

<p>其基本的思想是：对于一个输入样本（未知分类的样本），考虑其与测试样本中与之距离最近（特征最相似）的k个样本，用这k个样本中出现最多的分类作为输入样本的分类。</p>

<h4 id="section-1">具体流程</h4>
<hr />

<p>对于输入样本中的每一个点，进行以下操作：</p>

<ol>
  <li>计算点与测试样本中点的距离；</li>
  <li>取出与当前点距离最小的k个点；</li>
  <li>确定k个点的分类，计算各个分类的频数；</li>
  <li>返回频数最高的类别，作为该输入点的预测分类。</li>
</ol>

<h4 id="section-2">距离的计算</h4>
<hr />

<p>上面一直在说，计算输入样本中点与测试样本中点之间的距离，那么这个距离应该怎么计算呢？这个距离一般就是使用欧式距离：</p>

<script type="math/tex; mode=display"> d = \sqrt{(x - y)^T(x - y)} </script>

<p>其中<script type="math/tex">x^T=[x_1, x_2,\dots,x_n], y^T=[y_1,y_2,\dots,y_n]</script>。二维的表示就是：</p>

<script type="math/tex; mode=display"> d = \sqrt{(x - y)^T(x - y)} = \sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2} </script>

<h4 id="r">R语言实现</h4>
<hr />

<p>见<a href="https://github.com/JackyCode/Data_Science/tree/master/kNN">我的github</a>。</p>
]]></content>
  </entry>
  
</feed>
